1、Spring是一个容器，他可以更好的管理各个bean（对象）的关系

	为什么要使用Spring呢

	他的核心技术有

		SpringIOC

				核心：控制反转
			


				将传统的三层架构演变为容器管理，在以前的项目中一般是调用Dao供Service调用，
				在上面创建对象，而SpringIOC他会将你调用的Dao的对象在IOC容器中进行创建，也就是我们所说的注入
				这样减少了代码的耦合性，还有内存，因为在容器中他只会创造一次，使用时可以去容器中获取，这就是IOC的容器概念，



				实现原理：通过配置的bean并且配置类的对象路径，然后通过反射机制创建对象。这样的效率更高，可用性也高， 

					  并且不会重复创建对象，减少内存的浪费，便于提升性能
				


				@Resource是在JDK1.6才开始提供的，主要用于注入，寻常的@Autowried注解会以首字母小写去加载类，
				但是如果出现两个相同的就会报错，所以我们需要给他添加名称，@Autowried直接加载类@Resource加载设置的名称，这样就不会报错了，
				但是注意如果是使用JDK1.5的版本的就没有这个注解
		
		SpringAOP

				核心：面向切面编程

				1、关注点：

					关注重复的代码，我不想写那么多重复的代码该怎么办呢

				1、切面：

					

				1、切入点：


				面向切面一般有哪些通知呢，

		spring aop通知(advice)分成五类： 

				前置通知
		
					[Before advice]：
					
					在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常。 

				正常返回通知

					[After returning advice]：

					在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。
 
				异常返回通知

					[After throwing advice]：
		
					在连接点抛出异常后执行。 

				返回通知

					[After (finally) advice]：

					在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。 

				环绕通知

					[Around advice]：

					环绕通知围绕在连接点前后，比如一个方法调用的前后。这是最强大的通知类型，能在方法调用前后自定义一些操作。环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。 



		   
					前置通知

						锁定方法在执行前进行的操作例如打印日志等等

					后置通知
			
						锁定方法在执行完毕之后的操作例如打印日志等，他的执行结果

					异常通知

						锁定方法在发生异常之后的操作。例如记录日志等
	
					环绕通知

						锁定方法在执行前和执行后都进行操作

				使用代理设计模式（提供一个对目标的对象访问中介）
				也就是你想买车，车要销售，但是需要去4S店购买，4S店就是一个代理。类似于中间商的一个角色，负责买家和生产厂家的对接

				代理设计模式也分动态代理设计模式和静态代理设计模式

				静态代理模式就是需要手动创建一个对象传入进来（类似于new一个空的对象通过参数重新赋值，但是也是会进行对象创建）

				动态代理模式就是跳过创建，也就是买车直接找厂商，主要是通过反射的机制进行实现的，
				例如调用他的类模板，传入一个object对象，灵活可用且内存消耗极少
			
				

		DI

			

		事务管理



		传播行为





















