# 什么是Jvm虚拟机

# Jvm常见异常

## 堆内存异常

​	OutOfMemoryError

​	当我们在进行垃圾回收的时候出现的异常，这个是由于在垃圾回收老人区是使用FullGc回收不了从而引起堆内存对象无法存储，从而造成的堆内存的溢出，这个我们通常也成为OOM异常

## 栈异常

​	StackOverflowError

​	这个异常是栈内存溢出的异常，这个通常是由于方法循环的调用引起的，因为栈是先进后出的如果一直往里面进的话就会引发栈的内存溢出，是因为只进不出造成的，这个时候我们就需要找到无限循环调用的方法进行处理



# GC垃圾回收

​		GC是什么？

​			GC（分代收集算法），Young区（新生代），Old（老人代），Perm（永久代），

​		GC回收的是什么？

​			GC回收的是在Java的堆内存中产生的使用过的无效数据

​		有哪些GC回收？

​			GC    

​				是用于来回收新生代的回收机制，当新生代的内存要满的时候就会执行GC

​			FULL GC

​				是用于来回收老人代的回收机制，当老人代的内存要满的时候就会执行GC

## 回收的内存结构

​		在他回收的内存中既然是分代收集算法那么肯定分为上面的3代，我们先来简单的概述一下3种结构

​		

​			新生代

​				新生代是新创建的使用后的内存我们会将他进行垃圾回收，但是不一定能回收玩有可能没有回

​				收掉，那么在新生代中是分3个区的（伊甸园区，幸存0区，幸存1区），这三个分区和我们的

​				后面的GC的回收算法有很大的关联，首先当新生代的内存达到一定程度的时候我们就要进行垃

​				圾回收了，但是没有回收掉的数据怎么办呢？他就会进入到幸存0区，然后跟随下一次继续回收

​				，如果下一次还没有回收掉那么就会进入幸存1区然后再进行下一次的回收，如果还是回收不掉

​				怎么办呢？不用担心Java内置让我们在进行15次的垃圾回收的机制之后还是没有回收掉的数据

​				进入老人代



​				![](JVM\GC新生代.png)

​			老人代

​				在老人代中的数据是没有新生代那样频繁的清楚的

​			永久代（元空间）

## GC的四种垃圾回收算法

### 		复制算法(Copying)

### 		标记清除(Mark-Sweep)

### 		标记压缩(Mark-Compact)

### 		标记清除压缩(Mark-Sweep-Compact)





# JVM 的常用参数调优

​		JVM的调优调的到底是什么优？

-Xms1024m -Xmx1024m -XX:+PrintGCDetails

# 类加载器

​		通常来说类加载器有四种分别是：

​				1、自定义加载器（拓展）

​				2、应用类加载器

​				3、拓展类加载器

​				4、启动类加载器

​		而他们对应的级别是

​				启动类加载器  >  拓展类加载器  >  应用类加载器

## 		双亲委派机制：

​				首先找

​					应用类加载器    		如果没有找拓展类加载器

​									|

​									V

​					拓展类加载器			如果还是没有

​									|

​									V

​					启动类加载器			如果还是找不到的话就返回异常给拓展类加载器

​									|

​									V

​					拓展类加载器			将异常返回给应用类加载器

​									|

​									V

​								应用类加载器



​					双亲委派机制就类似于    儿子     父亲    爷爷三个角色

​					儿子找老爸要钱老爸没有，然后老爸找爷爷要钱爷爷也没有，然后爷爷给父亲说没钱了，

​					父亲又跟儿子说没钱了，这就是双亲委派机制

# Stack栈

​		什么是栈？

​		栈是一种数据结构，那么在java中的栈到底是一个什么样的结构呢？

​		栈是先进后出，后进先出的类似于如下

​		![](JVM\Stack.png)

​		那么栈是先进后出，后进先出，什么和他的特点相对立呢？

​		队列，队列是先进先出。后进后出的



# Heap堆

​		