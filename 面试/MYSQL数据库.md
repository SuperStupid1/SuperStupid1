# **数据库相关**

### 为什么推荐使用自增主键

​		大多时候我们都采用InnoDB引擎进行存储，我们知道主键索引也叫做聚簇索引，聚簇索引通过主键对数据进行索引，那么在我们不设置主键的情况下，MySQL会寻找不唯一的列作为索引，如果没有则会创建一个rowId进行存储，那么我们采用数值类型的索引可以方便查找，并且采用自增索引的话我们在插入的性能是非常高的，因为在table表中如果是自增的数据，会记录一个Id序列，也就是自增到哪了，我们在插入的时候直接插入到下一个Id序列作为主键ID即可，为了不让MySQL自己去进行定义主键或者自己创建rowid，我们自己指定那一列作为主键索引，并且设置自增（单节点MySQL推荐自增，分库分表情况特定）。

### MyISAM和InnoDB的区别

​			1、事务

​						InnoDB支持事务，MyISAM不支持事务

​			2、备份

​						InnoDB支持在线热备份					

​			3、崩溃恢复

​						MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。

​			4、并发

​						MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。

​			5、外键

​						InnoDB支持外键，而MyISAM不支持

​			6、全文索引

​						InnoDB不支持全文索引，而MyISAM支持

​			7、其他特性

​						MyISAM 支持全文索引，地理空间索引。

​			InnoDB的特点：

​						插入缓冲，二次写，自适应哈希索引，预读

### MySQL的日志有哪些？

​					1、错误日志

​								记录出错信息，也记录一些警告信息或者正确的信息

​					2、查询日志

​								记录所有对数据库请求的信息，不论这些请求是否得到了正确的执行

​					3、慢查询日志

​								设置一个阈值，将运行时间超过该值的所有SQL语句都记录到慢查询的日志文件中

​					4、二级制日志

​								记录对数据库执行更改的所有操作

​					5、中继日志

​					 			中继日志也是二进制日志，用来给slave 库恢复

​					6、事务日志(重做日志（redo log）)

​								作用是确保事务的持久性，防止在发生故障的时间点，尚有脏页未写入磁盘。

​								在重启 MySQL 服务的时候，根据 redo log 进行重做，

​								从而达到事务的持久性这一特性。		

​					7、回滚日志

​								保存了事务发生之前的数据的一个版本，可以用于回滚，

​								同时可以提供多版本并发控制下的读（MVCC），也即非锁定读。

### 常见的数据库优化手段索引的优缺点

​		常见的优化手段有：

​			1、在编写SQL语句时不使用*，而是使用字段名，哪怕每一个字段名都写上去，

​			2、添加索引，使查询效率变高，尤其是在where条件中的字段

​			3、尽量不要在列上进行运算（函数操作和表达式操作）否则索引失效

​			4、不使用not in  和 <>   以及！=否则索引失效

​			5、在使用like语句时不要以%开头否则索引失效

​			6、多表联查时多使用小表作为驱动表，因为（驱动表必须全表查询）

### 什么字段上建立索引数据库

​			1、在作为where条件出现较多的表

​			2、尽量建立索引时将顺序排好的字段（否则查询时中间一个字段没有用上后面的都用不上）

​			3、尽量选择一些和其他表有关联的字段，如订单表的用户字段

### 你们数据库的高可用架构是怎么样的？

​		一般来说数据库的备份我们采用主从复制（注：单纯的主从并不是高性能或者高可用的），而为了提高性能我们在主从之后会使用Mycat进行读写分离，但是他也只是做到了高性能并没有做到高可用，那么如何做到高可用呢，就是我们使用KeepAlive进行虚拟化ip，如果使用简单的高可用加高性能那么我们就直接通过KeepAlive，去连接主机然后再进行访问，如果主机挂掉了就直接使用丛机进行读写，等恢复主机之后将主机变为丛机，读取丛机的数据，或者恢复后同步数据，再使用指向主机，下面分别是高可用和一个高性能可用的架构图。

​		对于数据量以及并发量不太大的系统中可以推荐使用

​			双Master

​			双Master+双Slave

​		针对于数据量比较大的情况下我们就需要采用分库分表+多Master方式

​			分库分表+多Master+Slave

​		多Master是指MySQL双主机制，相互同步数据

### MySQL索引数据结构类型有几种

​					B+TREE 

​								采用B树的结构来存储索引数据。

​					HASH

​								采用Hash表的结构来存储索引数据。

​					R-TREE

​								R-TREE在MYSQL很少使用，仅支持geometry数据类型，支持该类型的存储引擎只有myisam、bdb、innodb、ndb、archive几种。相对于b-tree，r-tree的优势在于范围查找。							

​					FULL-TEXT

​								FULL-TEXT在mysql里仅有myisam支持它，而且支持full-text的字段只有char、varchar、text数据类型。full-text主要是用来代替like "%***%"效率低下的问题

​					为什么默认不使用Hash索引，Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。由于 Hash 索引比较的是进行 Hash 运算之后的 Hash 值，所以它只能用于等值的过滤，不能用于基于范围的过滤，因为经过相应的 Hash 算法处理之后的 Hash 值的大小关系，并不能保证和Hash运算前完全一样，所以默认采用B+TREE 。

### MySQL数据回表什么意思？

​		我们的所有的数据存储到MySQL，都是储存在MySQL的某一个主键中的通过某一个主键可以关联到所有的字段以及数据，那么数据回表是什么意思呢？

​		我们列举一下建立了复合索引的情况，我们给某个字段type建立了索引，那么会创建一个B+树的一个索引，这个索引存储了type类型，那么他会不会也存储所有的数据呢，答案肯定是否定的，那么我们根据这个type进行查询，如何查询我们的所有的数据字段呢？答案就是回表，我们通过type查询出符合条件的Id，然后根据这个Id去聚簇索引中进行回表查询出数据，然后再返回，在这个查询到了Id然后根据id再将数据从聚簇索引中拿到元数据，这个过程中我们称之为 “回表”。

​		![](https://blog-kang.oss-cn-beijing.aliyuncs.com/1611224235207.png)

### MySQL索引下推？

​		在MySQL5.6以后引入了一个查询中的优化操作，叫做索引下推，我们假设一张表，四个字段，id，name，type，email

​		如果我们给type建立了索引，那么我们使用如下语句的时候不会产生回表

```sql
select type from table where type = "type1"
```

​		但是当我们使用*以及 name和type的时候则会进行回表，因为我们只给type简历了索引

```sql
select name,type from table where type = "type1"
/* 或者 */
select * from table where type = "type1"
```

​		这样看是没什么问题，但是我们现在给name以及type都建立了索引

​		在使用如下SQL

```sql
 select * from table where name like 'kang%' and type = "type1"
```

​		数据如下

```
id		name  	type		email
1 		kang1		type2		***
2			kang2		type1		***
3			kang3		type1		***
4			kang4		type1		***
5			kang5		type2		***
6			kang6		type2		***
```

​		在5.6之前执行流程

```
1、根据索引查询到kang%的所有的ID（1、2、3、4、5、6）
2、根据查询到的ID进行回表（回表1、2、3、4、5、6）
3、再过滤type为type1（剩下2，3，4）
```

​		在5.6以及之后执行流程

```
1、根据索引查询到kang%的所有的ID（1、2、3、4、5、6）
2、索引中已经存在了type，直接再过滤type1（剩下2，3，4）
3、在进行回表（回表2、3、4）
```

​		我们可以看到回表的时候少回表了一半的数据，减少了回表的次数，提升了回表次数的损耗。

### 如何保证数据库主从一致性？

​		**方案一：忽略**

​				任何脱离业务的架构设计都是耍流氓，绝大部分业务，例如：百度搜索，淘宝订单，QQ消息，58帖子都允许短时间不一致。如果业务能接受，最推崇此法。别把系统架构搞得太复杂。

​		**方案二：选择性主读**

​				将哪个库，哪个表，哪个主键三个信息拼装一个key设置到cache里，这条记录的超时时间，设置为“主从同步时延” ，画外音：key的格式为“db:table:PK”，假设主从延时为1s，这个key的cache超时时间也为1s。 这是要读哪个库，哪个表，哪个主键的数据呢，也将这三个信息拼装一个key，到cache里去查询， 在cache里记录哪些记录发生过写请求，来路由读主还是读从 

### BTree和B+Tree的区别是什么？

​		

### MySQL采用的哪种结构存储索引？

​		MySQL采用B+树存储索引

### B+Tree和Bree哪个更加适合做索引？为什么？

​		B+Tree更适合做索引

### 你们生产用的是哪种事务隔离级别，为什么？

​		采用可重复读，也是MySQL的默认的事务隔离级别。

​		防止

### MySQL最多可以建立多少个索引

​		16个

### 什么情况下会造成索引失效？

​		1、使用or关键字，如果条件中有or，即使其中有条件带索引也不会使用 

​					注意：使用or，又想索引生效，只能将or条件中的每个列都加上索引 

​		2、索引顺序不一致，例如索引为（name，age，email），而查询时（name，email，age）则会造成只有name生效，其他两个字段用不到索引

​					注意：尽量避免索引顺序不一致，如果实在避免不了，在设计时就应先考虑顺序

​		3、以like %开头的关键字，如果以like %name查询，会使索引失效

​					注意：尽量使用 like name%这种，因为%号在后面还是能实用索引

​		4、如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不会使用索引 

​					注意：字符串类型列一定要使用引号（虽然情况很少）

​		5、 where语句中使用 <>和 !=   还有not  in，如果使用了不等于那么他会全表扫描

​					注意：尽量不要使用不等于或者not

​		6、 where语句中对字段表达式操作，例如where age * 2 = 100

​					注意：不要使用表达式，尽量使用age = 50

​		7、 使用函数，我们对查询中的条件进行一些函数计算，会导致索引失效

​					注意：尽量不要再查询条件中使用函数进行计算

### MySQL是如何通过MVCC实现事务的

​		



### 并发事务修改会造成哪些影响

会造成的常见影响有：

​			更新丢失：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题——最后的更新覆盖了其他事务所做的更新。

​			幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。

​			脏读：一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。

​			不可重复读：一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。

# 你所遇到的Mysql事故

### rancher引起

在使用rancher的时候，发现许多连接的错误，随之mysql就自动关闭了，这是什么原因呢

```
2019-08-14T11:18:30.558570Z 4 [Note] Aborted connection 4 to db: 'cattle' user: 'cattle' host: '10.18.16.99' (Got an error reading communication packets)
2019-08-14T11:18:30.558705Z 6 [Note] Aborted connection 6 to db: 'cattle' user: 'cattle' host: '10.18.16.99' (Got an error reading communication packets)
```

我们可以看到非常多的连接请求，然后读取数据报出错，那应该是连接的问题了，那么到底什么原因会引起mysql连接报错呢，当然就是连接数量太多所引起的，这个问题在rancher中能够体现，我们使用rancher监控服务器，然后重启了mysql，rancher就不停请求mysql，只要我们一重启mysql就直接崩溃了，所以我们需要

```
方法一：修改配置文件（永久生效）。
在/etc/my.conf文件加入 max_connections=2000 ，然后重启MySQL服务即可.

方法二：命令行修改（临时生效）
命令行登录MySQL后。设置新的MySQL最大连接数为2000：
MySQL> set global max_connections=2000;
```

然后还是发现有问题连接不上，是因为我们发送了太多的连接请求，超过了mysql的异常连接数量导致ip被mysql拒绝，这个时候我们需要刷新一下缓存

```
flush host
```

但是究竟是什么导致链接数上升，前端开始重建链接，由于当时的前端日志没有及时分析出来，故我们就不得而知了。但是有3个怀疑点：

1、由于mysql版本是5.5.12，所以可能遇到了max_connections的bug，可以见这个blog（http://www.cnblogs.com/billyxp/p/3408335.html），这种情况下，前端日志应该有非常多的too many connection是的报错。

2、短时间内有大量的大包传输，导致超过max_allow_packet的限制，导致断开连接。这个设置在server和client上都有，需要同步配置。同时前端应该报Got a packet bigger than ‘max_allowed__packet’ bytes这个报错。

3、超过max_connect_error的限制，导致某一个ip出现问题，不停的重试。（这个可能是最不可能，首先默认数值非常大，其次单个ip不应该出现这么大的影响。max_connect_error代表某一个ip连续失败超过n之后，server会拒绝这个ip的请求，只有flush host cache才可以解封。）

异常