# **Java基础** 

## 讲讲你所遇到过的异常

​	ConcurrentmodificationException		

​	这个异常是在多线程操作集合的时候产生的写并发写入的异常原因是因为操作没有加锁的对象例如ArrayList，HashSet，HashMap的时候，具体表现在高并发的添加上

## HashMap

​		HashMap核心变量：

​			Node<K,V>：链表节点，包含了key、value、hash、next指针四个元素

​			table：Node<K,V>类型的数组，里面的元素是链表，用于存放HashMap元素的实体

​			loadFactor：负载因子

​			size：记录了放入HashMap的元素个数

​			threshold：阈值，决定了HashMap何时扩容，以及扩容后的大小，一般等于table大小乘以

​						loadFactor

### HashMap有几个构造方法？

​		答：4个

​		分别是

```
//此方法用于设置HashMap的初始化长度，还有负载因子
public HashMap(int initialCapacity, float loadFactor) {  
    ...  
    this.loadFactor = loadFactor;  
    this.threshold = tableSizeFor(initialCapacity);  
}  

//此方法可以定义初始化长度
public HashMap(int initialCapacity) {  
    this(initialCapacity, DEFAULT_LOAD_FACTOR);  
}  
  
//默认初始化值
public HashMap() {  
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted  
}  
  

public HashMap(Map<? extends K, ? extends V> m) {  
    this.loadFactor = DEFAULT_LOAD_FACTOR;  
    putMapEntries(m, false); 
}  
```



### HashMap的源码，实现原理，JDK8中对HashMap做了怎样的优化。

   在JDK1.6，JDK1.7中，HashMap采用数组+链表实现 ，而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。 

​	核心重点：1.6,1.7   	数组+链表

​			   1.8 	数组+链表       长度超过8      ----->	转换为红黑树



### HaspMap扩容是怎样扩容的，为什么都是2的N次幂的大小。

​	为了能让 HashMap 存取高效，尽量较少碰撞，Hash 值的范围值-2147483648到2147483648，前后加起来大概40亿的映射空间。用之前还要先做对数组的长度取模运算，这个数组下标的计算方法是“ `(n - 1) & hash` ”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。

### HashMap，HashTable，ConcurrentHashMap的区别。

​	**HashTable**

​	底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住-整个HashTable，效率低，ConcurrentHashMap做了相关优化

​	初始size为11，扩容：newsize = olesize*2+1

​	计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length

### **HashMap**

底层数组+链表实现，可以存储null键和null值，线程不安全

初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂

扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入

插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）

当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀

计算index方法：index = hash & (tab.length – 1)

 ConcurrentHashMap

1.6时底层采用分段的数组+链表实现，线程安全

通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)

1.8版本时采用数组+链表+红黑树

取消segments字段，直接采用`transient volatile HashEntry<K,V> table`保存数据，采用table数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。 





Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术



有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁



扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容

### 极高并发下HashTable和ConcurrentHashMap哪个性能更好，为什么，如何实现的 

​	`ConcurrentHashMap` 的性能仍然保持上升趋势，而 `Hashtable` 的性能则随着争用锁的情况的出现而立即降了下来。 

​	核心：

​		Hashtable使用 ` synchronized` 作为锁，而在高并发情况下疯狂抢锁会损耗性能，ConcurrentHashMap使用锁桶（或段）。 ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶 ，所以他在高并发情况系会比HashTable快很多

### HashMap在高并发下如果没有处理线程安全会有怎样的安全隐患，具体表现是什么 

Hashmap在并发环境下，可能出现的问题：

​	1、多线程put时可能会导致get无限循环，具体表现为CPU使用率100%；  

​			在HashMap每次put的时候都会检测，他的长度跟负载因子算出的阙值，如果在put的时候原来的Hash表放不下了，那么就会进行扩容， 扩容的长度为两倍，例如16的长度负载因子12，如果达到13那么就扩容到32，如果下次达到24那么就会再次扩容，他扩容的方式就是创建一个新的Hash表将原来的数据存储进去，这个过程就是一个数据的迁移过程，rehash ()的过程，多线程操作就有可能形成循环链表，如果使用get方法就会出现Infinite Loop的情况，在无限循环的过程中会造成cpu占满从而引起卡死，崩溃等等情况

​	2、多线程put时可能导致元素丢失 

​			当多个线程同时执行addEntry(hash,key ,value,i)时，如果产生哈希碰撞，导致两个线程得到同样的bucketIndex去存储，就可能会发生元素覆盖丢失的情况 

## ArrayList

### ArrayList的初始化以及扩容的实现过程



​		ArrayList的初始化他的容器大小时0，因为ArrayList在初始化的时候不会进行容器的初始化

​		他会在第一次添加的时候给他的容器进行赋值，他的大小是10

​		并且在他的扩容的时候是在add的时候容器大小不够触发，扩容为原来容器的1.5倍

### 什么情况下你会使用ArrayList？什么时候你会选LinkedList？

​		在ArrayList中使用的是数组，那么他的查询效率就会高，因为他的查询时间复杂度为0（1），而LinkedList的采用的是双向链表，所以他的查询的时间复杂度为O（N），所以在查询比较多的情况下我们使用ArrayList，那么又来看一下使用LinkedList的场景，我们知道ArrayList的删的时候他会去进行一个位移的操作，在中间添加的时候他会查询并且位移，那么他的时间复杂度为O（n），而LinkedList采用双向链表，那么他可以从节点的上一个节点指向节点的下一个直接就进行了删除时间复杂度为O（1），所以在频繁的操作元素的时候使用LinkedList

## 类

### java中四种修饰符的限制范围。

​		public

​			不同包，非子类，只要项目内都可以访问

​		protected

​			只有当前类和子类还有本包能够使用，

​		default

​			只有当前类和本包能够使用

​		private

​			只有本类能够使用

### Object类中的方法。

```
 1 registerNatives()   //私有方法
 
 2 getClass()    //返回此 Object 的运行类。
 
 3 hashCode()    //用于获取对象的哈希值。
 
 4 equals(Object obj)     //用于确认两个对象是否“相同”。
 
 5 clone()    //创建并返回此对象的一个副本。 
 
 6 toString()   //返回该对象的字符串表示。   
 
 7 notify()    //唤醒在此对象监视器上等待的单个线程。   
 
 8 notifyAll()     //唤醒在此对象监视器上等待的所有线程。   
 
 9 wait(long timeout)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或        者超过指定的时间量前，导致当前线程等待。 
 
10 wait(long timeout, int nanos)    //在其他线程调用此对象的 notify() 方法或 notifyAll() 方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。

11 wait()    //用于让当前线程失去操作权限，当前线程进入等待序列

12 finalize()    //当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
```

## 动态代理

### 动态代理的两种方式，以及区别。

​		**一般而言，动态代理分为两种，一种是JDK反射机制提供的代理，另一种是CGLIB代理。在JDK代理，必须提供接口，而CGLIB则不需要提供接口，在Mybatis里两种动态代理技术都已经使用了，在Mybatis中通常在延迟加载的时候才会用到CGLIB动态代理。** 



​		通过实现接口InvocationHandler，然后在他的invoke方法上面进行动态代理

​		CGLIB的类似于jdk的动态代理，但是不用提供接口

## JAVA库相关

### Java序列化的方式。

​		1、实现Serializable接口

​		2、实现Externalizable接口

### 传值和传引用的区别，Java是怎么样的，有没有传值引用 

- 传值：传递的是值的副本。方法中对副本的修改，不会影响到调用方。
- 引用：传递的是引用的副本，共用一个内存，会影响到调用方。此时，形参和实参指向同一个内存地址。对引
- 用副本本身（对象地址）的修改 



### 一些较新的东西JDK8的新特性，流的概念及优势，为什么有这种优势

​		个人感觉，一项技术需要有生命周期地进行更新，所以会出现一些新式的东西，可能好用也有可能不好用，但是他的存在肯定是有意义的，像Lambda表达式和Stream流这是JDK8的新特性中比较火的两个特性，那么他们分别又做了什么呢？先来说说Lambda它体现了函数式编程这个概念，其实在很多地方已经有这个概念了，例如前端ES6的规范中，而且他不单单是一个概念，也是一个革新，他还能帮助我们简化代码，尤其是在编写匿名内部类的时候，这就是他为什么会产生（因为这个概念是已经有的，并且8的版本开发出来了，而且也能简洁代码，还能体现函数式编程），那么再来说一下Stream流的概念，

​		流的概念数据流（data stream）最初是通信领域使用的概念，代表传输中所使用的信息的数字编码信号序列。然而，我们所提到的数据流概念与此不同。这个概念最初在1998年由Henzinger在文献87中提出，他将数据流定义为“只能以事先规定好的顺序被读取一次的数据的一个序列”。 

​		那么Stream流有什么优势呢？

（1）速度更快

（2）代码更少（增加了新的语法Lambda表达式）

（3）强大的Stream API

（4）便于并行

（5）最大化减少了空指针异常Optional

其中最为核心的为 Lambda 表达式与Stream API 



​		流注重的不是不是数据，而是计算，Stream他并不会自己存储元素，只能通过其他获取，而且他也不会修改源对象，只会产生新的数据，他的流式计算方便快捷，效率非常高，但是不适合作为存储容器，他更适合计算数据，数据筛选之类



### @transactional注解在什么情况下会失效，为什么 

1，检查方法是不是public 

2，检查异常是不是unchecked异常 

3，如果是checked异常也想回滚的话，注解上写明异常类型即可 @Transactional(rollbackFor=Exception.class) 

# **数据结构和算法** 

## B+树

## 快速排序，堆排序，插入排序 

## 一致性Hash算法，一致性Hash算法的应用

## 链表和数组的优缺点？ 

## 解决hash冲突的方法有哪些？ 

# **JVM** 

## JMM的内存模型

​	JMM内存模型简单的将他分为5大块分别为

​		方法区

​		堆

​		栈

​			当我们调用一个方法时，我们可以将这个调用的方法的线程看为一个栈，这个线程会随着栈的运行完成而执行完毕，然后进行销毁，栈是一个数据结构先进后出，后进先出，栈中有栈底和栈顶

​		本地方法栈

​			本地方法栈是Java调用本地方法是所使用的，它是与底层的C语言或者CPU，或者操作系统进行的交互

​		程序计数器（PC寄存器）

​			程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 

## JVM的启动方式

JVM有两种运行模式Server与Client。两种模式的区别在于

​	HotSpot 虚拟机默认使用Server模式启动

​	Client模式启动速度较快

​	Server模式启动较慢



​		但是启动进入稳定期长期运行之后Server模式的程序运行速度比Client要快很多。这是因为Server模式启动的JVM采用的是重量级的虚拟机，对程序采用了更多的优化；而Client模式启动的JVM采用的是轻量级的虚拟机。所以Server启动慢，但稳定后速度比Client远远要快。 

## JVM的内存结构 

## G1

​	G1将新生代，老年代的物理空间划分取消了 ，取而代之的是，G1算法将堆划分为若干个区域（Region），它仍然属于分代收集器 。不过，这些区域的一部分包含新生代，新生代的垃圾收集依然采用暂停所有应用线程的方式，将存活对象拷贝到老年代或者Survivor空间。老年代也分成很多区域，G1收集器通过将对象从一个区域复制到另外一个区域，完成了清理工作。这就意味着，在正常的处理过程中，G1完成了堆的压缩（至少是部分堆的压缩），这样也就不会有cms内存碎片问题的存在了 

## JVM方法栈的工作过程，方法栈和本地方法栈有什么区别 

​	方法栈：存储栈帧，支持Java方法的调用、执行和退出 

​	本地方法栈：作用是支撑Native方法的调用、执行和退出 

​	本地方法栈Native方法是基于系统还有底层的实现，它并不是调用的Java代码

## JVM的栈中引用如何和堆中的对象产生关联 

​	栈中的栈帧用来存储内存地址，通过PC计数器进行引用，它类似于C中的指针，可以帮助栈引用到堆中的堆内存对象

## 说一下逃逸分析技术 

#### 逃逸分析

​		逃逸是指在某个方法之内创建的对象除了在方法体之内被引用之外，还在方法体之外被其它变量引用到；这样带来的后果是在该方法执行完毕之后，该方法中创建的对象将无法被GC回收。由于其被其它变量引用，由于无法回收，即称为逃逸。

​		逃逸分析技术可以分析出某个对象是否永远只在某个方法、线程的范围内，并没有“逃逸”出这个范围，逃逸分析的一个结果就是对于某些未逃逸对象可以直接在栈上分配提高对象分配回收效率，对象占用的空间会随栈帧的出栈而销毁。

​		总结：虽然他被引用之后导致了无法回收，但是它是随着栈的结束而结束掉的，而一个栈对应一个线程，这个线程一结束就会被销毁了

## GC的常见算法，CMS以及G1的垃圾回收过程，CMS的各个阶段哪两个是Stop the world的，CMS会不会产生碎片，G1的优势 

​		

## 标记清除和标记整理算法的理解以及优缺点 



​		标记清除：就是将要被回收的内存对象进行标记，然后统一的去清除，但是在这个过程中会产生大量的不连续的内存碎片，并且标记然后清除的效率不高

​		

​		标记整理：它是将标记的 内存进行先标记然后整理然后再清除，所以他不会产生内存碎片，但是他所耗费的资源更多

​		

## JVM如何判断一个对象是否该被GC，可以视为root的都有哪几种类型 

​	是根据他的引用强度进行垃圾回收的，引用分为四种

​	强引用(Strong)

​			 就是我们平时使用的方式 A a = new A();强引用的对象是不会被回收的

​	软引用(Soft) 

​			在jvm要内存溢出(OOM)时，会回收软引用的对象，释放更多内存

​			是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异

​			常之前，将会把这些对象列进回收范围之中进行第二次回收。 

​	弱引用(Weak) 

​			在下次GC时，弱引用的对象是一定会被回收的

​			 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下

​			一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关

​			联的对象。 

​	虚引用(Phantom)

​			 对对象的存在时间没有任何影响，也无法引用对象实力，唯一的作用就是在该对象被回收时收到一

​			个系统通知

​	视为root的有

​			虚拟机栈(JVM stack)中引用的对象(准确的说是虚拟机栈中的栈帧(frames))  

​			方法区中类静态属性引用的对象  

​			本地方法栈(Native Stack)引用的对象 

## 什么情况下类会被回收掉

​		堆中不存在该类的任何实例

​		加载该类的classloader已经被回收

​		该类的java.lang.Class对象没有在任何地方被引用，也就是说无法通过反射再带访问该类的信息	

## 如何判断一个对象需要被回收

​		1、引用计数法

​			引用计数法思路是这样的，给对象添加一个引用计数器，有地方引用时，计数器就加1；当引用失效时就减1；当计数为0的时候就判定对象需要被回收

引用计数法有一个难以解决的问题就是相互循环引用问题。这样就会造成无法回收，并且JVM用的是可达性分析

​		2、可达性分析算法

​			这个算法的基本思路是通过一些列称为“GC Roots”的对象作为起始点，从这些点开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明对象需要被回收. 

​		被视为Roots的对象有

​			虚拟机栈中引用的对象

​			方法区中类静态属性引用的对象

​			方法区中常量引用的对象

​			本地方法栈中JNI引用的对象

## 强软弱虚引用的区别以及GC对他们执行怎样的操作 

​		强引用一般在GC的时候都不会去回收他，所以强引用过多JVM就算抛出OOM异常也不会去回收他



​		对象是虚可达到对象 ，虚引用对象在那时或者在以后的某一时间，它会将该引用加入队列， 所以他其实只是会发出一个通知，但是他在某一个时间段还是会加入队列，所以在每次GC他都会被清理但是每次都又会回归队列

## System.gc()可以进行垃圾回收么？ 

​		System.gc()是一个Java提供的函数，看似他是进行Gc操作的，实际上它并不能进行Gc，因为Java并没有提供手动gc的任何方法，那么他的作用是什么呢？



​		System.gc()他只是帮助我们提醒一下虚拟机需要回收垃圾了，但是他并不会一定去执行垃圾回收的操作，只是起到了一个提醒的作用

## Java类加载的过程 

加载：

​		通过一个类的全限定名来获取定义此类的二进制字节流 ，将这个字节流所代表的静态存储结构转化为方

​		法区域的运行时数据结构。 在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区域数据

​		的访问入口 

验证：

​		验证阶段作用是保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害。如果验证失

​		败，就会抛出一个java.lang.VerifyError异常或其子类异常。验证过程分为四个阶段 准备：



​		 1.文件格式验证：验证字节流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理。 

​		 2.元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范。 

​		 3.字节码验证：主要是进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害虚拟机。 

​		 4.符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解

​						析阶段中发生。 

准备 :

​		准备阶段为变量分配内存并设置类变量的初始化。在这个阶段分配的仅为类的变量（static修饰的变

​		量），而不包括类的实例变量。对已非final的变量，JVM会将其设置成“零值”，而不是其赋值语句的值

 

​		 pirvate static int size = 12; 

​		 那么在这个阶段，size的值为0，而不是12。 final修饰的类变量将会赋值成真实的值。 

解析：

​		解析过程是将常量池内的符号引用替换成直接引用。

​		主要包括四种类型引用的解析。

​			类或接口的解析、

​			字段解析、

​			方法解析、

​			接口方法解析 

初始化 ：

​		在准备阶段，类变量已经经过一次初始化了，在这个阶段，则是根据程序员通过程序制定的计划去初始

​		化类的变量和其他资源。这些资源有static{}块，构造函数，父类的初始化等。 



​		 至于使用和卸载阶段阶段，这里不再过多说明，使用过程就是根据程序定义的行为执行，卸载由GC完

​		成。 

使用 :

​		新线程---程序计数器----jvm栈执行（对象引用）-----堆内存（直接引用）----方法区 

卸载:

​		 GC垃圾回收 

## 双亲委派模型的过程以及优势 

​		

启动类(引导类)加载器 Bootstrap ClassLoader

​		 虚拟机的一部分，由c++实现。负责加载<JAVA_HOME>/lib下的类库

扩展类加载器 Extension ClassLoader,

​		sun.misc.Launcher$ExtClassLoader.负责加载<JAVA_HOME>/lib/ext下的类库

应用程序类加载器 Application ClassLoader 

​		sun.misc.Launcher$AppClassLoader, 它是System.getClassLoader()的返回值，也称为系统类加载器。		

​		负责加载用户类路径上所指定的类库。如果应用程序没有自定义过类加载器 

自定义类加载器：

```
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个层次的类加载器都是如此

如果从应用层类加载器加载，那么他会将任务交给父类（扩展类加载器），扩展类加载器将任务交给启动类加载器

如果启动类加载器无法完成加载任务（找不到需要加载的类）那么他就会将任务递交给子类，如果启动类加载器加载不了则交给扩展类加载器，拓展类加载到了那么就直接返回结果，如果还是加载不到则继续往下，如果一直加载不了那么就会无法加载此类找不到类


java.lang.ClassNotFoundException
```

## 常用的JVM调优参数 

### 	**jvisualvm.exe**的使用

​		产生OOM异常时生成Dump文件		

​			-XX:+HeapDumpOnOutOfMemoryError

​			然后找到	

​			java的、bin目录下的**jvisualvm.exe** 

​			选中pid运行的线程，右键打印dump文件，然后进行分析



​		-Dcom.sun.management.jmxremote=true -Dcom.sun.management.jmxremote.port=9090 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false

​		使用jvisualvm监控9090这个端口的java信息

​		**Trace跟踪参数** 

​				打开GC跟踪日志（每次执行GC的信息都能打印，获得执行时间，空间大小）：

​				-verbose:gc 或 -XX:+printGC 或 -XX:+printGCDetails

​				类加载监控：（监控类加载的顺序）

​				-XX:+TraceClassLoading

​		**堆的分频参数** 

​				-Xmx10M 指定最大堆，JVM最多能够使用的堆空间 （超过该空间引发OOM）

​				-Xms5M 指定最小堆，JVM至少会有的堆空间（尽可能维持在最小堆）

​				-Xmn 11M（new） 设置新生代大小

​		**栈的分配参数**

​				-Xss 每个线程都有独立的栈空间（几百k，比较小）

​				需要大量线程时，需要尽可能减小栈空间

​				栈空间太小-----StackOverFlow栈溢出（一般递归时产生大量局部变量导致）

### jconsole的使用

 		

javap反编译的使用

jdb是一个断点工具 

jps查询Java进程

jstat查询运行数据

jstatd同样用于监控JVM实例 

jinfo打印特定JVM实例的配置信息

jmap用于查看JVM的so对象内存占用情况或指定的JVM实例堆内存情况 

jstack用于打印指定进程的调用堆栈信息 



## Java有没有主动触发GC的方式 

# **多线程** 

## 关于HashMap，HashSet，和ArrayList集合的线程安全以及解决方案

​		其实HashMap，HashSet，和ArrayList接口的这些都是线程不安全的，他们在多线程操作的时候都会产生线程安全的问题，具体体现在多线程的添加的时候都会出现ConcurrentModificationException这个异常，那是由于多线程的修改同一个数据引起的

那么如何解决呢

解决ArrayList可以使用的方法

```
使用Vector修饰
List<String> map = new Vector<>();

使用Collections的工具类给List上锁
List<String> map = Collections.synchronizedList(new ArrayList<>());

使用JUC工具包CopyOnWriteArrayList的写时复制List
List<String> map = new CopyOnWriteArrayList<>();
```

解决HashMap的问题

```
使用Collections的工具类给Map上锁
Map<String,Object> hash = Collections.synchronizedMap(new HashMap<>());

使用ConcurrentHashMap并发工具包
Map<String,Object> hash = new ConcurrentHashMap<>();
```

解决HashSet的问题

```
使用Collections的工具类给Set上锁
Set<String> set = Collections.synchronizedSet(new HashSet<>());

使用JUC工具包CopyOnWriteArraySet的写时复制List
Set<String> set = new CopyOnWriteArraySet<>();
```



## **AbstractQueuedSynchronizer**（AQS）（JUC并发包实现的基类）

AbstractQueuedSynchronizer的使用依靠继承来完成，子类通过继承自AQS并实现所需的方法来管理同步状态。

提供了一个基于FIFO队列，可以用于构建锁或者其他同步装置的基础框架 

AQS可以同时实现排它锁和共享锁模式

使用方法是继承，子类通过继承并通过实现它的方法管理其状态｛acquire 和release｝的方法操纵状态

 

## 怎么检测一个线程是否拥有锁 

​	java.lang.Thread中有一个方法叫holdsLock() ，返回true表示当前线程有锁

## 同步和异步有什么区别

同步异步通常形容方法的调用过程

同步：

​    	同步就是方法的执行必须有序，也就是我调用一个方法，这个方法必须执行完我才能继续执行；即有序执行 

异步：

​	异步就是在方法调用的时候不用等待也能执行其他的方法，例如我在调用一个方法时我还能调用其他的方法，不必等待前面的方法执行完再执行下一个

## 并发、并行有什么区别

​	并发：多个任务轮流争取CPU的资源，多个任务交替执行，看起来好像多个程序一起执行其实还是多个任务在共享一个CPU

​	并行：每个线程使用一个CPU，真正的一起执行 

## 临界区（锁，资源争抢）

​	表示一个公共资源或者共享数据，可以被多个线程使用;每一次，只能有一个线程使用它，一旦临界区资源被专用(加锁)，其他线程想要使用这个资源，就必须等待； 

## 阻塞、非阻塞有什么区别

​	阻塞：当一个线程占用了临界资源（被上锁的临界资源），那么当其他线程想要访问临界资源的时候，就必须等待，等待会导致线程挂起，即将当前线程放入到等待队列中，直到被唤醒； 

​	非阻塞：线程之间的执行不受共享资源的状态影响，即不会被挂起； 

## 线程之间的锁机制会引发哪些问题

​	死锁：线程间相互的调用，所引起的锁资源获取不到导致无限等待循环，例如A需要执行B后才能释放锁，C需要执行A后释放锁，B有需要C执行后释放锁，导致锁释放不出来。没人拿的到这个锁造成的死锁

​	活锁：两个线程互相主动将资源释放，让给对方，但没有一个线程可以同时拿到所有资源而正常执行 

​	饥饿： 线程因为某种原因(例如线程的优先级比较低)一直等待资源，无法获取所需要的资源，导致一直无法执行 

## 进程，线程的区别是什么

​	进程：是系统进行资源分配和调度的基本单位，进程是基本执行的实体，是线程的容器，运行一个程序，就相当于运行一个进程。当我们程序有很多小的任务需要执行的时候，我们使用进程进行任务之间的切换，比较费时，且数据交换麻烦，因此引入线程 

​	线程：是程序执行的最小单位，线程之间可共享数据，线程之间切换的成本较低，一个进程包含很多线程； 

## 多线程的一些性质

​	原子性：Atomicity 

​		原子性指的是一个操作不可能被中断，即如果多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰； 

​	可见性：Visibility 

​		可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改；对于串行来说，不存在这个问题，此问题只针对于并行； 

​	有序性：Ordering 

​		当程序执行时，有可能会进行指令重拍，重拍后的指令和原指令的顺序未必一致； 

## 线程的状态有哪些

​	创建New

​		新建状态表示刚刚创立的简称，这个线程还没有开始执行，需要等到start()方法调用时，才表示线程执行； 

​	启动Runnable

​		运行状态表示线程所需的一些资源都已经准备好了，可以执行 

​	阻塞Blocked

​		阻塞状态，表示当遇到Synchronized同步块是，就会进行blocked阻塞状态，这个线程会暂停执行，直到获取请求的锁 

​	停止Waiting

​		Waiting/Time Waiting:Waiting等待状态会进入一个无时间限制的等待 

​		Time_Waiting会进行一个有时间的等待； 

​	结束Terminated

​	有限等待Time_Waiting 

## 线程有哪些方法

终止线程stop()

线程中断lnterrupt()

睡眠sleep()

等待wait(),notify()

挂起suspend()

等待线程结束join()、谦让yield()： 

synchronized关键字 

## Java实现多线程有哪几种方式 

​		有四种

​				1、继承Thread类

​				2、实现Runnable接口

​				3、实现Callable接口

​				4、线程池

## Callable和Future的了解

​		Callable接口代表一段可以调用并返回结果的代码 

​		Future接口表示异步任务，是还没有完成的任务给出的未来结果 

​		所以说Callable用于产生结果，Future用于获取结果。 

## CyclicBarrier和CountDownLatch的区别是什么？ 

​		CountDownLatch，使用的是减计数的方式，计算为0时释放所有等待的线程，计数为0时无法重置，调用countDown方法进行计数减一，调用await方法进行阻塞，对计数没有任何的影响

​		CyclicBarrier，使用的是加计数的方式，计数达到指定值时释放，计数重置为0重新开始，调用await时+1，如果加1不等于构造方法的值则线程阻塞，他是可重复利用的

### 线程池的接口和依赖的关系

​	Executor				父类接口

​	ExecutorService			继承Executor

​	AbstractExecutorService	实现ExecutorService

​	ThreadPoolExecutor 		继承AbstractExecutorService

### 线程池的几个参数

int corePoolSize							//核心线程数,允许同时执行任务的最大线程数

int maximumPoolSize						// 最大线程数，允许同时处理任务的最大线程数

long keepAliveTime						// 超出核心线程数的空闲线程的最大存活时间

TimeUnit unit							//空闲线程存活时间单位

BlockingQueue<Runnable> workQueue		// 阻塞任务队列，存储待执行的任务

ThreadFactory threadFactory				// 线程工厂，用于创建线程，可指定线程命名规则

RejectedExecutionHandler handler			// 饱和策略(拒绝策略)，当线程池阻塞队列已满时对新任务的处理

​	ThreadPoolExecutor.AbortPolicy;		//丢弃任务并抛出RejectedExecutionException异常。 			

​	ThreadPoolExecutor.DiscardPolicy;		//也是丢弃任务，但是不抛出异常。 		

​	ThreadPoolExecutor.DiscardOldestPolicy;//丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）

​	ThreadPoolExecutor.CallerRunsPolicy;	//由调用线程处理该任务 

### 常见的线程池有哪几种

​	**1. newSingleThreadExecutor** 



​		创建一个单线程的线程池。这个线程池仅仅有一个线程在工作，也就是相当于单线程串行运行全部任务。假设这个唯一的线程由于异常结束，那么会有一个新的线程来替代它。此线程池保证全部任务的运行顺序依照任务的提交顺序运行。 



​	**2. newFixedThreadPool** 



​		创建固定大小的线程池。每次提交一个任务就创建一个线程。直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变。假设某个线程由于运行异常而结束，那么线程池会补充一个新线程。 



​	**3. newCachedThreadPool** 



​		创建一个可缓存的线程池。假设线程池的大小超过了处理任务所须要的线程.那么就会回收部分空暇（60秒不运行任务）的线程，当任务数添加时。此线程池又可以智能的加入新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小全然依赖于操作系统（或者说JVM）可以创建的最大线程大小。



​	**4. newScheduledThreadPool** 

​		创建一个大小无限的线程池。此线程池支持定时以及周期性运行任务的需求。

## 如何自定义一个线程池

​	首先是我们要知道线程池的核心是什么其实就是从ThreadPoolExecutor中创建来的，那么我们来看一下ThreadPoolExecutor的使用，分别介绍了他的7个参数以及用法，首先

5											是核心线程数

10											是最大线程数（最大线程数中包含核心线程数）

3L											表示超时时间3，单位不确定

TimeUnit.MICROSECONDS						表示超时时间单位						

​	TimeUnit.DAYS          			 //天  
​	TimeUnit.HOURS        			 //小时  
​	TimeUnit.MINUTES      		 //分钟  
​	TimeUnit.SECONDS      		 //秒  
​	TimeUnit.MILLISECONDS  		 //毫秒 
​	TimeUnit.NANOSECONDS   	 //毫微秒

​	TimeUnit.MICROSECONDS  	//微秒

 Executors.defaultThreadFactory()				使用Executors默认的线程工厂

new LinkedBlockingQueue<>(30)				阻塞队列长度为30，一个项目的最大并发数就是最大线程数+阻塞队列数

​			常用的三个阻塞队列（一共）

​			SynchronousQueue			单个阻塞队列

​			ArrayBlockingQueue			由数组构建的有界的阻塞队列

​			LinkedBlockingQueue			由链表构建的无界的阻塞队列（默认为Integer的max值也就是21亿，不推荐直接使用最大值）

new ThreadPoolExecutor.CallerRunsPolicy()		拒绝策略

​			ThreadPoolExecutor.AbortPolicy;	 	如果超过了阻塞队列+最大线程池的数量的并发抛出异常 			

​			ThreadPoolExecutor.DiscardPolicy;		如果超过了阻塞队列+最大线程池的数量的并发直接丢弃

​			ThreadPoolExecutor.DiscardOldestPolicy如果超过了阻塞队列+最大线程池的数量的并发丢弃最前面的尝试执行下一个线程，也就是超过的有可能被执行一次

​			ThreadPoolExecutor.CallerRunsPolicy	如果超过了阻塞队列+最大线程池的数量的并发如果自己处理不了那么交给调用的线程执行，也就是main线程调用线程池，但是超过了，那么线程池处理不了交给main线程进行执行

```
        Executor executor = new ThreadPoolExecutor(
                5,
                10,
                3L,
                TimeUnit.MICROSECONDS,
                new LinkedBlockingQueue<>(30),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy());
```

​	这个就是自定线程池的过程，那么我们来介绍如何合理的设置线程池参数

### 合理线程池参数定制

​	CPU密集型

​		由于要保证线程的计算速度也就是高利用CPU的性能

​		计算模式

​			（注：单核CPU告辞）

​			CPU核数+1

​	IO密集型

​		分两种

​			CPU * 2		(推荐第二种)

​			CPU / 1  - 阻塞系数	阻塞系数为0.8-0.9

## 什么是JMM

​	JMM就是Java的内存模型

## 什么是CAS

​	CAS是英文单词Compare and Swap的缩写，翻译过来就是比较并替换 ，他

## volitile关键字的作用，原理 

​		他是一个轻量级的同步机制，保证内存可见性（Memory Visibility）常用于保持内存可见性和防止指令重排序。 所有线程都能看到共享内存的最新状态，但是他不保证原子性。

```
public class MutableInteger {
    private int value;
    public int get(){
        return value;
    }
    public void set(int value){
        this.value = value;
    }
}

MutableInteger不是线程安全的，因为get和set方法都是在没有同步的情况下进行的。如果线程1调用了set方法，那么正在调用的get的线程2可能会看到更新后的value值，也可能看不到。

```



Java通过几种原子操作完成`工作内存`和`主内存`的交互 

1. lock：作用于主内存，把变量标识为线程独占状态。
2. unlock：作用于主内存，解除独占状态。
3. read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。
4. load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。
5. use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。
6. assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。
7. store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。
8. write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。

### volatile如何保持内存可见性

volatile的特殊规则就是：

- read、load、use动作必须**连续出现**。
- assign、store、write动作必须**连续出现**。

所以，使用volatile变量能够保证:

- 每次`读取前`必须先从主内存刷新最新的值。
- 每次`写入后`必须立即同步回主内存当中。

也就是说，**volatile关键字修饰的变量看到的随时是自己的最新值**。线程1中对变量v的最新修改，对线程2是可见的。 



volatile解析

https://www.cnblogs.com/monkeysayhi/p/7654460.html

## synchronized关键字的用法，优缺点 

​		可以用在代码块上，还有方法上面，synchronized 粒度有些大，在处理实际问题时存在诸多局限性。

## Lock接口有哪些实现类，使用场景是什么 

​		Lock有三个实现类

​			ReentrantLock （可重入锁）

​			ReentrantReadWriteLock.ReadLock（读锁）

​			ReentrantReadWriteLock.WriteLock（写锁）

## 可重入锁的用处及实现原理 

### 什么是可重入锁

​	可重入锁ReentrantLock，他是一个可重入锁



​		同时他实现了公平锁和非公平锁，可以通过他的构造方法来进行指定

```
        ReentrantLock nonfairSync = new ReentrantLock(false);
        ReentrantLock fairSync = new ReentrantLock(true);
```

​		具体体现在他的构造方法中

​		![](img\可重入锁构造方法.png)

​	并且默认的构造方法是非公平锁

​	![](img\可重入锁默认构造方法.png)

### 什么是公平锁

​	公平锁表示线程公平，按序执行，并且保证原子性

```
import java.util.concurrent.locks.ReentrantLock;

public class MyFairLock {
    /**
     *     true 表示 ReentrantLock 的公平锁
     */
    private  ReentrantLock lock = new ReentrantLock(true);

    public   void testFail(){
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName() +"获得了锁");
        }finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {
        MyFairLock fairLock = new MyFairLock();
        Runnable runnable = () -> {
            System.out.println(Thread.currentThread().getName()+"启动");
            fairLock.testFail();
        };
        Thread[] threadArray = new Thread[10];
        for (int i=0; i<10; i++) {
            threadArray[i] = new Thread(runnable);
        }
        for (int i=0; i<10; i++) {
            threadArray[i].start();
        }
    }
}
```

输出结果

![](img\公平锁.png)

​		这样的话那么他就是一个公平锁我们可以

### 什么是非公平锁

非公平锁不保证公平性，不会刻意去控制线程，但是性能高

```
public class MyNonfairLock {
    /**
     *     false 表示 ReentrantLock 的非公平锁
     */
    private  ReentrantLock lock = new ReentrantLock(false);

    public  void testFail(){
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName() +"获得了锁");
        }finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {
        MyNonfairLock nonfairLock = new MyNonfairLock();
        Runnable runnable = () -> {
            System.out.println(Thread.currentThread().getName()+"启动");
            nonfairLock.testFail();
        };
        Thread[] threadArray = new Thread[10];
        for (int i=0; i<10; i++) {
            threadArray[i] = new Thread(runnable);
        }
        for (int i=0; i<10; i++) {
            threadArray[i].start();
        }
    }
}
```

![](img\非公平锁.png)

## 读写锁 

## 线程的状态都有哪些 

​		创建   

​		准备

​		运行或者阻塞

​		死亡

​		一共有5个状态

## sleep和wait的区别 

​		sleep是睡眠，他指定了一个时间，他会时刻的监视这个时间如果一旦到达就会继续运行，但是wait的睡眠他会让进入到一个类似等待池的状态，在这个状态中他是真正的睡眠，如果不去唤醒他会一直进入到休眠，这个时候就需要唤醒了，我们可以使用notify（在只有两个线程时）他会被其他线程唤醒，但是如果多个线程都在睡眠，这个情况下使用notify就不一定有效了，那么我们可以使用notifyall

## notify和notifyall的区别 

​		notify是唤醒一个线程，这个线程并不能我们指定的去唤醒，但是他会让正在休眠的线程中的某一个线程唤醒，而notifyall则是让所有的睡眠的线程进行唤醒

# **数据库相关** 

## 常见的数据库优化手段索引的优缺点 

​		常见的优化手段有：

​			1、在编写SQL语句时不使用*，而是使用字段名，哪怕每一个字段名都写上去，

​			2、添加索引，使查询效率变高，尤其是在where条件中的字段

​			3、尽量不要在列上进行运算（函数操作和表达式操作）否则索引失效

​			4、不使用not in  和 <>   以及！=否则索引失效

​			5、在使用like语句时不要以%开头否则索引失效

​			6、多表联查时多使用小表作为驱动表，因为（驱动表必须全表查询）

​			

## 什么字段上建立索引数据库 

​			1、在作为where条件出现较多的表



​			2、尽量建立索引时将顺序排好的字段（否则查询时中间一个字段没有用上后面的都用不上）

​			

​			3、尽量选择一些和其他表有关联的字段，如订单表的用户字段

## 你们数据库的高可用架构是怎么样的？ 

​		一般来说数据库的备份我们采用主从复制（注：单纯的主从并不是高性能或者高可用的），而为了提高性能我们在主从之后会使用Mycat进行读写分离，但是他也只是做到了高性能并没有做到高可用，那么如何做到高可用呢，就是我们使用KeepAlive进行虚拟化ip，如果使用简单的高可用加高性能那么我们就直接通过KeepAlive，去连接主机然后再进行访问，如果主机挂掉了就直接使用丛机进行读写，等恢复主机之后将主机变为丛机，读取丛机的数据，或者恢复后同步数据，再使用指向主机，下面分别是高可用和一个高性能可用的架构图

​		![](img\MySQL高可用.png)

![](img\MySQL主从高可用.png)

## 如何保证数据库主从一致性？ 

​		**方案一：忽略**

​				任何脱离业务的架构设计都是耍流氓，绝大部分业务，例如：百度搜索，淘宝订单，QQ消息，58帖子都允许短时间不一致。如果业务能接受，最推崇此法。别把系统架构搞得太复杂。

​		**方案二：选择性主读**

​				将哪个库，哪个表，哪个主键三个信息拼装一个key设置到cache里，这条记录的超时时间，设置为“主从同步时延” ，画外音：key的格式为“db:table:PK”，假设主从延时为1s，这个key的cache超时时间也为1s。 这是要读哪个库，哪个表，哪个主键的数据呢，也将这三个信息拼装一个key，到cache里去查询， 在cache里记录哪些记录发生过写请求，来路由读主还是读从 

## 为什么mongodb的索引用了B树，而mysql用B+树？

​		我们首先来看一下B树的结构

​			B树的特点就是每一层的节点数据非常多，而层数比较少，目的就是为了减少IO次数

​			B树的每个节点都是有data域的（指针），这无疑增大了节点大小

​		再来看一下B+树的结构

​			B+树的特点就是，B+树所有的Data域在叶子节点 ，非叶子节点存储索引数据

​			B+树只要遍历叶子节点就可以实现整棵树的遍历

## 用mysql过程中，有遇到什么问题么？ 

## 你们生产用的是哪种事务隔离级别，为什么？ 

## 什么情况下会造成索引失效？

​		1、使用or关键字，如果条件中有or，即使其中有条件带索引也不会使用 

​					注意：使用or，又想索引生效，只能将or条件中的每个列都加上索引 

​		2、索引顺序不一致，例如索引为（name，age，email），而查询时（name，email，age）则会造成只有name生效，其他两个字段用不到索引

​					注意：尽量避免索引顺序不一致，如果实在避免不了，在设计时就应先考虑顺序

​		3、以like %开头的关键字，如果以like %name查询，会使索引失效

​					注意：尽量使用 like name%这种，因为%号在后面还是能实用索引

​		4、如果列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不会使用索引 

​					注意：字符串类型列一定要使用引号（虽然情况很少）

​		5、 where语句中使用 <>和 !=   还有not  in，如果使用了不等于那么他会全表扫描

​					注意：尽量不要使用不等于或者not

​		6、 where语句中对字段表达式操作，例如where age * 2 = 100

​					注意：不要使用表达式，尽量使用age = 50

# 数据结构



# **计算机网络** 

## TCP，UDP区别 

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接



2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付



3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）



4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信



5、TCP首部开销20字节;UDP的首部开销小，只有8个字节



6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道



总结：

​		TCP面向连接，即：需要连接才能发送数据，并且TCP提供的服务是可靠的有序的，不重复，不丢失，他将数据看成字节流进行传输，点对点的连接，TCP头部开销20字节，TCP是逻辑通信的可靠信道

​		

​		UDP是无连接的直接发送，UDP不保证可靠地将消息交付，UDP没有拥堵或阻塞状态，不会让发送效率变低，UDP可以一对一，一对多，多对多，多对一，首部8个字节，UDP是不可靠信道



​	优缺点对比：



​			TCP慢，但是消息传送可靠，并且无差错不丢失，但是效率并不高，并且首部开销大，还有可能阻塞或者拥堵



​			UDP是无连接的，不需要询问对方直接发送，发送速度快，并且没有阻塞拥堵状态，还能一对多多对多，首部开销少，但是不保证消息的可靠性，容易丢失，



​	在根据不同的场合使用不同的技术



## TCP核心

​			TCP的Flags有几个

​				URG：紧急指针标志

​				ACK：确认序号编制

​				PSH：push标志

​				RST：重置连接标志

​				SYN：同步序列好，用于建立连接过程

​				FIN：finish标志，用于释放链接

​			这些flags就是用于TCP的通信的核心

## 三次握手 

​		TCP如何进行三次握手的呢？

​				假设我们通过A去访问B那么，A就会带着一个SYN进行连接请求B，这是第一次握手，如果B收到了并且统同意连接，那么B就会向A发送一个ACK+SYN用于确认并且请求连接，这里就是第二次的握手，然后A收到了B的ACK表示B已经同意了连接，那么A就会响应一个ACK表示收到了请求，这个时候就是真正的连接并且传输了，最后的连接就是第三次握手，这个就是TCP的三次握手

​		![](img\三次握手.png)

下面是完整的示例图：

```
** LISTEN ** 表示socket已经处于listen状态了，可以建立连接；

** SYN_SENT ** 表示socket在发出connect连接的时候，会首先发送SYN报文，然后等待另一端发送的确认报文(ACK)，表示这端已经发送完SYN报文了

** SYN_RCVD ** 表示一端已经接收到SYN报文了；

** ESTABLISHED ** 表示已经建立连接了，可以发送数据了

```

​	![](img\三次握手2.png)



## 四次挥手 

​		什么是TCP的四次挥手呢？

​		TCP的四次挥手就是A连接到了B，并且完成传输数据之后，这个连接关闭的过程我们称之为四次挥手，

​	TCP的四次挥手的过程	

​		那么我们又来假设A已经连接到了B，那么我们需要断开连接，首先我们的A会向B发起一个FIN来表示他传输完成，需要进行资源的释放，这里A向B发送了一个FIN表示第一次挥手，然后B收到了这个FIN，表示他知道了需要关闭资源，那么B就会给A发送一个ACK表示他收到了，然后进入到半关闭的CLOSE_WAIT状态，这个时候就是第二次挥手，然后B虽然处于了半关闭的状态，但是还是可以发送消息的，这个时候他会再次给A发送一个FIN表示，我已经关闭，你也关闭吧，这里就是第三次的挥手，那么A就会给B发送一个ACK表示他也收到了会进行关闭（但是不会立即关闭），这里的ACK表示A收到了然后给B发送确认，B收到之后才会进行关闭

![](img\四次挥手.png)

下面是完整示例

```
** FIN_WAIT_1 ** 表示在等待另一方的FIN报文，和FIN_WAIT_2的区别是，FIN_WAIT_1表示socket现在要主动关闭连接，在发送完FIN报文后socket进入FIN_WAIT_1状态，当收到另一方发送FIN的ACK之后立即进入FIN_WAIT_2状态；

** FIN_WAIT_2 ** 同上，此时需要做的事情是可能还会接收数据，然后等待另一方的FIN；

** TIME_WAIT ** 存在主动关闭的一方，表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL(Max Segment Lifetime))后即可回到CLOSED可用状态了，需要等一段时间时原因是网络是不可靠的，不能保证这个ACK发送成功了，如果失败了，对端会超时重传FIN；

** CLOSING ** 表示在发送FIN之后，没有收到对方的ACK，而是收到了对方的FIN，这中情况很少见，只有在两端几乎同时关闭同一个socket的时候才会出现CLOSING状态；

** CLOSE_WAIT ** 表示收到对方的FIN之后，回给对方ACK，此时处于CLOSE_WAIT状态，等待关闭，要看自己是否还有数据要发送；

** LAST_ACK ** 表示收到对方的FIN之后，回给对方ACK，然后自己也要关闭发送FIN，等待另一方的ACK时候的状态；

** CLOSED ** 这个状态表示连接已经断开。

```

![](img\四次挥手2.png)

## 为什么要三次握手

​		因为我们要知道TCP的通信是一定要保证数据的投递的可靠性，还有一致性，所以他建立连接的时候必须要确定双方的状态，要保证一定的可靠的投递，所以需要三次握手保证双方的数据传输环境，然后再进行通信

## 为什么要四次挥手 

​		由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 

## 长连接和短连接 

​		HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。



​		在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。  



​		而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

## 连接池适合长连接还是短连接 

​		连接池适合长连接，因为在使用连接池的时候我们需要快速的连接，并且持续性的，所以我们使用长连接，在一般的连接池中也会设定最小连接数，和空闲连接数为的就是能快速的持续的传输数据所以连接池适合使用长连接

​		

# **分布式相关** 

## 分布式事务 

CAP定理

​			分布式的不可能全部满足三个需求

​				一致性（C：Consistency）

​				可用性（A：Availability）

​				分区容错性（P：Partition tolerance） 

​				CA  

​					放弃分区容错性，加强一致性和可用性，其实就是传统的单机数据库的选择 

​				CP

​					放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此 

​				AP

​					放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用 

​		分布式事务可以使用多个方案





Base(Basically Available，Soft state,Eventually consistent)：一种 ACID的替代方案 

​	Basically Available（基本可用）

​		基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性----注意，这绝不等价于系统不可用 ，比如响应时间慢了1秒或者下订单失败进入失败页面，其实这就是一个强一致性

​	Soft state（软状态）

​		软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时 ，也就是数据同步时间不一致，也称弱一致性

​	Eventually consistent（最终一致性）

​		最终一致性强调的是所有的数据副本，在经过一段时间的同步之后，最终都能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。当这个程序执行完成之后所有的数据都一致，这个是最终一致性

### 2PC

​				2PC是基于XA协议的两阶段提交协议（Two- Phase Commit Protocol）

​				预提交阶段(Pre-Commit Phase)

​					两阶段提交在应用程序向协调者发出一个提交命令时被启动。这时提交进入第一阶段，即预提交阶段 .协调者准备局部（即在本地）提交并在日志中写入"预提交"日志项，并包含有该事务的所有参与者的名字 ,如果全部都提交答复并且不否定则进入到第二个提交阶段，如果其中有一个参与者不能参与答复，或者否定了一个，那么就会取消事务，撤销他们的影响



​				决策后阶段（Post-Decision Phase）

​					如果所有的参与者都送回"已准备好提交"的消息，则该事务的提交进入第二阶段，即决策后提交阶段，协调者在日志中写入"提交"日志项，并立即写入硬盘 ，然后送回"已提交"的消息，释放该事务占用的资源。  如果所有都回复已提交那么就完成事务的提交，如果提交发生异常则回滚



​			优点：

​				 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。 

​			缺点：

​				实现复杂，牺牲了可用性，对性能影响较大，涉及多次节点间的网络通信，通信时间太长，不适合高并发高性能场景 

### TCC

​				TCC（Try Confirm Cancel） 其实就是采用的补偿机制，

​					Try

​						这里是对业务系统做检测及资源预留

​					Confirm

​						在 Confirm 阶段，执行远程操作，如果成功则直接成功，如果失败则执行Cancel

​					Cancel

​						主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放

​				 优点：实现简单，方便

​				 缺点：数据的一致性差，并且需要写非常多的补偿代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理 

### CAP



### MQ 事务消息

​	 有一些第三方的 MQ 是支持事务消息的，比如 RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交

​		第一阶段 Prepared 消息，会拿到消息的地址。

​		第二阶段执行本地事务

​		第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。 

​	，	一次发送消息和一次确认消息。如果确认消息发送失败了 RocketMQ 会定期扫描消息集群中的事务消息，这时候发现了 Prepared 消息，它会向消息发送者确认，所以生产方需要实现一个 check 接口，RocketMQ 会根据发送端设置的策略来决定是回滚还是继续发送确认消息。 

​		优点： 实现了最终一致性，不需要依赖本地数据库事务。

​		缺点： 实现难度大，主流MQ不支持，没有.NET客户端，RocketMQ事务消息部分代码也未开源。

## 分布式锁如何设计 

​		分布式锁的设计有三种



​			数据库

​				

​			Redis

​				使用setnx并且设置超时时间，只有一个人能拿到锁，拿到了锁就直接进行数据库查询然后将数据添加到Redis当中，然后没有拿到锁的先睡眠一秒（防止还是没有数据，一秒钟可以将数据存入缓存），然后调用自己的方法回去，现在再次查询redis已经是有数据的了，这样就实现了分布式查询锁

​			Zookeeper

​				

## 分布式session如何设计 

​		分布式session的实现方式有很多种

​			基于数据库的session共享

​			基于Redis的session缓存

​			基于cookie的session共享

​		这里我们推荐使用Redis，因为数据库性能并不高，而且我们也需要减少数据库压力，而cookie则容易被获取，从而造成数据的安全隐患，所以使用Redis既能优化速度，也能保证安全，还能方便清理

## dubbo的组件有哪些 

​		Remoting: 网络通信框架，实现了 sync-over-async 和request-response 消息机制. 

​		

​		RPC: 一个远程过程调用的抽象，支持负载均衡、容灾和集群功能

​		

​		Registry: 服务目录框架用于服务的注册和服务事件发布和订阅

## dubbo是如何利用接口就可以通信的 

那我们就先来从dubbo的在通信中使用到的数据吧，

​	**Protocol：**注册协议，包括zookeeper、multicast、Redis、simple； 

​	Address：**注册地址，dubbo服务的IP+Port：

​					   ①、当使用zk，address填入zk地址，集群地址使用","分隔；

​					   ②、使用dubbo直连，address填写直连地址和服务端口；

​	**Protocol：**使用的dubbo协议，包括dubbo、rmi、hessian、webservice、memcached、redis，根据自己的协议类型选择对应的选项即可； 

​	**Timeout：**请求超时时间，单位ms，根据dubbo具体配置填写； 

​	Version：**版本，dubbo不同版本之间差异较大，不同版本之间不能互相调用，这里指定dubbo版本，是为了方便识别和说明； 

​	**Retries：**异常重试次数（类似这种分布式服务通信框架，大多都有重试机制，是为了保证事务成功率）； 

​	**Cluster：**集群类型，包括failover、failfast、failsafe、failback、failking； 

​	**Group：**组类型，如果有的话，根据配置填写即可； 

​	**Connections：**连接数，同上，根据配置填写； 

​	**Async：**服务处理类型，包括sync（同步）、async（异步），根据配置填写； 

​	**Loadbalance：**负载均衡策略，包括random（随机）、roundrobin（轮询）、leastactive（最少活跃数）、consistenthash（一致性哈希）； 

​	**Interface：**接口名（因为dubbo服务大多是开发根据规范自行命名的，因此这里需要填写完整的接口名+包名）； 

​	**Method：**当前接口下的方法名，按照开发提供的API文档填写即可； 

​	**Args：**接口报文，根据API文档填写，如上图所示，添加输入行，输入对应的参数类型和值即可（参数类型和值如何定义填写，请参考上面的链接）； 

​	①、paramType：参数支持任何类型，包装类直接使用`java.lang`下的包装类，小类型使用：`int``、``float``、``shot``、``double``、``long``、``byte``、``boolean``、``char`，自定义类使用类完全名称； 

​	②、paramValue：基础包装类和基础小类型直接使用值，例如：int为1，boolean为true等，自定义类与`List`或者`Map`等使用json格式数据； 



​	这里我们可以看到他记录了非常多的东西，甚至ip以及协议，接口名，方法名还有参数，那么他回去进行匹配zookeeper的节点，如果匹配了就通过ip和接口还有方法名进行调用，他的调用的过程是不经过zookeeper的，因为我们拿到了ip和接口就可以直接进行rpc的远程调用，甚至与如果zookeeper挂掉了，其实他们地也是有缓存的还能继续使用，从这点可以看出并没有经过zookeeper，rpc的远程调用使用的原理是socket，那么他在通信是已经拿到了ip那么就可以直接调用他的服务了，这就是dubbo利用通信的原理

## Zookeeper在选举的过程中，还能对外提供服务么？ 

​		这个就需要结合情况看了，如果是单纯的使用zookeeper的话那肯定是对外提供不了服务了，但是如果是使用的dubbo的话那就是还能使用的，因为dubbo是将服务的注册信息都写入到了zookeeper的节点中，如果他开始就通过zookeeper调用过的话本地是有缓存的，当zookeeper在选举的过程中，如果他还是调用访问过的服务那就是没问题的，除非缓存过期了，

# Web相关

## Cookie和Session的区别

Cookie以文本文件格式存储在浏览器中，而session存储在服务端它存储了限制数据量。它只允许4kb它没有在cookie中保存多个变量。

cookie的存储限制了数据量，只允许4KB，而session是无限量的

我们可以轻松访问cookie值但是我们无法轻松访问会话值，因此它更安全

设置cookie时间可以使cookie过期。但是使用session-destory（），我们将会销毁会话。

## Serlvet的生命周期

初始化	---》	运行	---》 	销毁

初始化	init()



​		init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用，当用户调用一个 Servlet 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载 ，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法 



运行	service()



​		service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。 每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。 



销毁	destroy()

​	

​		destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。在调用 destroy() 方法之后，servlet 对象被标记为垃圾回收。



## Jsp和Servlet的区别

​	jsp经编译后就变成了Servlet，jsp更擅长表现于页面显示,servlet更擅长于逻辑控制，Jsp是Servlet的一种简化，使用Jsp只需要完成程序员需要输出到客户端的内容，Jsp中的Java脚本如何镶嵌到一个类中，由Jsp容器完成，Servlet更多的是类似于一个Controller，用来做控制



​	区别：

​			Servlet在Java代码中通过HttpServletResponse对象动态输出HTML内容

​			JSP在静态HTML内容中嵌入Java代码，Java代码被动态执行后生成HTML内容

## Tomcat是什么

​	Tomcat是一个应用端的Web服务器，属于轻量级应用服务器，tomcat除了实现了http协议，用来接收和响应Http请求

## Tomcat和Servlet的区别

​	，Tomcat实际上也是一个Servlet容器，但是这个端是在Web服务层的，而Java还需要经过动态的响应以及处理需要和Web服务端进行交互，那么这个交互的容器就是Servlet，而Servlet就会进行一系列的处理响应给Tomcat

## Request和Response的区别是什么

​		Request对象是服务器对浏览器所发送过来的请求的封装，而Response是是服务器对浏览器的响应的对象，里面所封装了请求头和响应头，封装了请求的请求信息，以及响应的响应信息

## 四大域和九大内置对象

​		Request域

​			request请求对象 

​		Page域

​			response响应对象 

​			pageContext页面上下文对象 

​			out输出对象 

​			config配置对象 

​			page页面对象

​			exception例外对象 

​		Application域

​			application应用程序对象

​		Session域

​			session会话对象 

# **缓存相关**

## redis和memcached的区别 

​		相对于 Memcached，来说如果他断电了数

​			据也就没有了，不能像Redis一样支持数据的持久化，在这一点上Redis做的比他好，并且它包含了

​			Memcached的几乎所有的功能并且比他更加强大，作为Java来说Redis是一个不错的缓存数据库，

​			这只是Redis的一部分功能，还有更多的强大的功能，并且Memcached只支持json格式的字符串，	

​			但是Redis支持很多种数据类型，所以在现在的市场上Memcached已经逐渐被Redis取代了

## redis支持哪些数据结构 

​		五种数据类型：

​						字符串（String）

​						哈希（hash）

​						字符串列表（list）

​						字符串集合（set）

​						有序字符串集合（zset       sorted set）

​		但是在Redis5.0中发布了新的数据类型

​			Stream data type 

## redis是单线程的么，所有的工作都是单线程么 

​		Redis是单线程的，redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。 所有的工作并不是单线程的，而是使用I/O的多路复用，



​		Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的 



​		那么什么是多路I/O的复用呢？		

​		多路指的是多个TCP连接，复用指一个或者多个线程进行处理，在Redis中是单线程的，简单的理解就是多个TCP连接进行数据写入的请求，通过一个单线程进行多路的IO写入，这个就是多路IO复用，但是I/O的多路复用也是有很多种模型的，常见的有、	select	 、  poll  	、epoll	

​		而在Redis当中使用的epoll

## redis如何存储一个String的 

​		通过他的Key  Value的键值对进行存储，

## 一个key值如何在redis集群中找到存储在哪里 

​		一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每
个键都属于这 16384 个插槽的其中一个， 集群使用公式 CRC16(key)
% 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计
算键 key 的 CRC16 校验和 。
• 集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群
可以有主节点， 其中：
节点 A 负责处理 0 号至 5500 号插槽。
节点 B 负责处理 5501 号至 11000 号插槽。
节点 C 负责处理 11001 号至 16383 号插槽。

​		那么redis如果有3个节点，就会根据他的key进行计算key的CRC16的值然后来对16384 进行取模的操作

​		也就是（Key 计算后的CRC16    %     16384），然后再计算取模后的值在哪一个节点中，例如取模后是3000，那么他就会找到3000的这个槽，3000的这个槽是在A节点（1-5500）（假设为3个节点），那么他就会在第一个节点进行存储，如果查找的话也会去第一个节点进行查询

## redis持久化策略 

### 		RDB

​					RDB的存储方式：在指定的时间间隔内将内存中的数据集快照写入磁盘，也
​						就是行话讲的Snapshot快照，它恢复时是将快照文件直接
​						读到内存里



​		Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入
​		到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换
​		上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，
​		这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据
​		恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。
​		RDB的缺点是最后一次持久化后的数据可能丢失



​		rdb的保存的文件： 在redis.conf中配置文件名称，默认为dump.rdb

​		![](img\drb.png)



​		下面就是他的持久化的文件存储的路径



​		RDB持久化的保存策略

​		这是他的保存策略，如果60秒内发生了10000次数据操作则进行一次存储，

​		如果300秒发生了10次则会存入一次。如果900秒内发生了一次操作那么900秒后

​		就会备份一次，

​		![](img\保存策略rdb.png)

​		stop-writes-on-bgsave-error yes
​		当Redis无法写入磁盘的话，直接关掉Redis的写操作

​		rdbcompression yes
​		进行rdb保存时，将文件压缩

​		rdbchecksum yes
​		在存储快照后，还可以让Redis使用CRC64算法来进行数
​		据校验，但是这样做会增加大约10%的性能消耗，如果希
​		望获取到最大的性能提升，可以关闭此功能

​	rdb的备份

​					先通过config get dir 查询rdb文件的目录
​					将*.rdb的文件拷贝到别的地方

​			 	rdb的恢复

​			 		先把备份的文件拷贝到工作目录下
​		 			关闭Redis
​		 			启动Redis, 备份数据会直接加载

​				注：清先看清楚配置文件的RDB的文件名和路径

​	优点：

​					 节省磁盘空间
 					 恢复速度快

​	rdb的缺点

​					虽然Redis在fork时使用了写时拷贝技术,

​					但是如果数据庞大时还是比较消耗性能



​					在备份周期在一定间隔时间做一次备份，所以如果
​					Redis意外down掉的话，就会丢失最后一次快照后的所有修改	

### 		AOF

​	 AOF默认不开启，需要手动在配置文件中配置

​			 可以在redis.conf中配置文件名称，默认为 appendonly.aof

​			![](img/AOF.png)

​		这分别是是否开启。默认是关闭的而RDB默认是开启的，他的路径和RDB是一样的

​		下面这个就是文件名了

​		

​		那么如果RDB好AOF同时启动的话他会执行哪个呢？

​			AOF的备份机制和性能虽然和RDB不同, 但是备份和
​			恢复的操作同RDB一样，都是拷贝备份文件，需要
​			恢复时再拷贝到Redis工作目录下，启动系统即加载

​			**AOF和RDB同时开启，系统默认取AOF的数据**

​		持久化AOF

​			 AOF文件的保存路径，同RDB的路径一致

​			 如遇到AOF文件损坏，可通过
​				redis-check-aof --fix appendonly.aof 进行恢复



​		AOF优点：

​				恢复数据全，不会丢失数据

​		缺点：

​				占用磁盘空间较大，并且恢复没有RDB快

- 如果只配置AOF，重启时加载AOF文件恢复数据；
- 如果同时配置了RBD和AOF，启动是只加载AOF文件恢复数据;
- 如果只配置RBD，启动时将加载dump文件恢复数据。

## 你们用了redis，redis的底层数据结构了解多少？ 

​		简单动态字符串

​		链表

​		字典

​		跳跃表

​		整数集合

​		压缩列表

## 知道动态字符串sds的优缺点么？ 注:sds为redis底层数据结构之一 

​	核心：

​		更加高效的执行长度计算：

​				在C中获取长度是需要进行遍历的，但是在sds中直接获取size属性，时间复杂度为O(1)，C的原生字符串获取长度为O(n)



​		更加高效的执行追加操作：

​				他在拓展的时候会比实际的多，例如追加10但是他扩容了15个，这样的话他下面5次追加就不会进行扩容了，而且他使用了惰性空间释放，也就是例如多出了10个空间他会把这10个记录下来，留着下次追加使用，而不是直接将10个空间进行释放，但是这样会让我们的内存空间变大，这个也可以手动进行释放（在SDS）的Api中有记录



​		二进制安全：

​				因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。 



sds 会为追加操作进行优化：加快追加操作的速度，并降低内存分配的次数，代价是多占用了一些内存，而且这些内存不会被主动释放。

## redis的单线程特性有什么优缺点？ 

优点：	

1. 代码更清晰，处理逻辑更简单
2. 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
3. 不存在多进程或者多线程导致的切换而消耗CPU

缺点：

1. 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；

 

## 用过 Redis 的哪些数据结构, 分别用在什么场景? 

### 		String

​			String类型他并不是只能存储String，也能用来存储Long，等等，他可以用来存储一些结构简单的数据，并且效率非常高，像日常的一些单个的值往里面存，例如用户的token，还有用户的信息

### 		Hash

​			Hash是一个字典类型，这个时候我们可以用它来存储一些需要频繁修改的对象，例如用户的积分（但一般也是在数据库中存储，Redis存储一般用来提高效率），那么我们需要对用户的积分进行改动，而且这种改动还比较频繁，那么我们可以使用Hash来进行存储这个用户对象，因为如果使用String的话他会全部的序列化出来再存储进去，这样造成的大量IO比较消耗性能

### 		List

​			List是一个列表，他其实是一个链表，但是更多的使用时是将他当做一个消息队列来使用，因为他可以push和pop这和Java中的Queue队列一样，我们可以使用它来做一个消息队列

### 		Set

​			Set是一个集合，他和Java中的Set也是一样的无序的不唯一的值，如果使用的话场景还是比较多的，例如向的好友列表，还有关注的用户，和粉丝，以及还能用来统计访问用户，比如统计某一天的用户访问量，和访问过的用户

### 		ZSet

​			ZSet是一个有序的集合，他可以用来存储集合并且做一个排序，那么我们可以使用他来进行一个点赞的操作，应为他去重并且有序，但实际上来说ZSet的应用场景其实并不多



​		这几个数据类型更多的是结合实际的业务需求来进行使用的



## 你们怎么解决缓存击穿问题的？ 

​		使用分布式锁，设置ex以及过期时间，然后进行数据库查询并重新添加到Redis中，没有获取到锁的对象Seelp睡眠一秒然后重新调用方法，这样就解决了缓存击穿的问题

# **框架相关**

## SpringMVC的Controller是如何将参数和前端传来的数据一一对应的 

​		其实还是用到了servlet的取值方式，如果参数中有一个strring类型的name属性，那么它就会从request作用域中获取一个name的属性，如果获取到了就封装成一个String类型的，然后绑定到参数中

## Mybatis如何找到指定的Mapper的，如何完成查询的 

​		通过他的namespace ，也就是他的命名空间，其实我们可以不写Mapper接口的，也能直接调用xml中的方法，通过他的sqlSessionFactory工厂中加载xml，然后找到他的namespace，然后调用指定的方法，但是我们用Mapper接口进行映射，并且将它交给Spring容器进行管理，简化了开发效率，并且降低代码的耦合度

## Spring的拦截器过滤器以及监听器的区别

​		拦截器（Spring）

​			通过实现HandlerInterceptor接口进行使用，可以拦截请求并且处理，true同行，false拒绝

​			postHandle()：这个方法在handler执行后，但是DispatcherServlet 向客户端返回响应前被调用，在该方法中对用户请求request进行处理。 

​			afterCompletion()：这个方法在 DispatcherServlet 完全处理完请求后被调用，可以在该方法中进行一些资源清理的操作。view渲染完成、dispatcherServlet返回之前执行 

​		过滤器

​			通过实现java定义好的javax.servlet.Filter接口 进行使用，他是基于Servlet的，			

​			doFilter(ServletRequest, ServletResponse, FilterChain)：这是一个完成过滤行为的方法。这同样是上游过滤器调用的方法。引入的FilterChain对象提供了后续过滤器所要调用的信息。如果该过滤器是过滤器链中的最后一个过滤器，则将请求交给被请求资源。也可以直接给客户端返回响应信息。init(FilterConfig)：由Web容器来调用完成过滤器的初始化工作。它保证了在第一次doFilter()调用前由容器调用。您能获取在 web.xml 文件中指定的初始化参数。destroy()：由Web容器来调用来释放资源，doFilter()中的所有活动都被该实例终止后，调用该方法。

​		监听器

​			实现ServletContextListener 接口 

​			spring容器的加载要在servlet之后，因此在有些过滤器当中需要提前用到spring bean的时候，就需要改成 Listener 的方式 

​			org.springframework.web.context.ContextLoaderListener 

​			自动装配ApplicationContext的配置信息。因为它实现了ServletContextListener这个接口，注：如果在xml中配置了初始化加载，然后在代码中再次地实现了ContextLoaderListener ，那么它会初始化两次



​	区别：

​			拦截器是Spring所封装的

​			过滤器和监听器是SpringMVC封装的Servlet的监听和过滤器

​		

## Spring使用了哪些设计模式 

​		那么就先举几个比较常用的spring的设计模式吧（不是全部！）

​		1、简单工厂模式（Sample Factory）

​				这个体现在BeanFactory上使用了工厂模式

​		2、代理模式（Proxy Pattern）

​				代理模式主要体现在AOP的动态代理上

​		3、单例模式（Single Pattern）

​				单例模式就是在spring的容器对象中体现

​		4、模版方法模式（Template Method）

​				模板方法就是通过反射拿到Bean的类模板

​		5、观察者模式（Oberver Pattern）

​				这个体现在Spring的监听器中

## Spring的IOC有什么优势 

​		控制反转，将一个对象，通过反射，再使用单例将对象加载到Spring的容器中，大大减少频繁new对象，并且频繁new对象所造成的内存其实是非常浪费的，例如每次一个人来访问，就会new一个实现类对象，然后调用其中的方法，这样多个人调用他就会产生多个内存对象，造成资源浪费，而且他们所调用的都是一样的方法，这样就会产生耦合，在Spring中是不被允许的，因为开发的代码质量要注重高内聚低耦合的思想，所以使用IOC来管理对象一是节约了内存空间。二是降低了代码的耦合度，三是实现了控制的反转，以前是需要一个对象就new一个，但是我们将他放到容器中要用从容器中拿出来直接用即可

## Spring的bean的生命周期 

​		1、instantiate bean对象的实例化

​		2、populate properties封装属性

​		3、如果Bean实现BeanNameWare执行setBeanName

​		4、如果Bean实现BeanFactoryAware 或者 ApplicationContextAware 设置工厂 setBeanFactory 或者上下文对象 setApplicationContext

​		5、如果存在类实现 BeanPostProcessor（后处理Bean） ，执行postProcessBeforeInitialization，BeanPostProcessor接口提供钩子函数，用来动态扩展修改Bean。(程序自动调用后处理Bean)

​		6、如果Bean实现InitializingBean 执行 afterPropertiesSet 

​		7、调用<bean init-method="init">指定初始化方法 init

​		8、如果存在类实现 BeanPostProcessor（处理Bean） ，执行postProcessAfterInitialization

​		9、执行业务处理

​		10、如果Bean实现 DisposableBean 执行 destroy

​		11、调用<bean destroy-method="customerDestroy"> 指定销毁方法 customerDestroy

## Spring的BeanFacoty和ApplicationContext的区别



​		 Spring核心工厂是BeanFactory ,BeanFactory采取延迟加载，第一次getBean时才会初始化Bean, 



​		 ApplicationContext是对BeanFactory扩展，ApplicationContext是会在加载配置文件时初始化Bean。它可以进行国际化处理、事件传递和bean自动装配以及各种不同应用层的Context实现 

​		

## Spring是什么呢？

​		是一个IOC，APO框架，是一个生态体系，是一个一站式Java框架，也是一个容器

## SpringMVC的运行流程

​		1、用户发送请求至前端控制器DispatcherServlet

​		2、DispatcherServlet收到请求调用HandlerMapping处理器映射器。

​		3、处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。

​		4、DispatcherServlet调用HandlerAdapter处理器适配器

​		5、HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)

​		6、Controller执行完成返回ModelAndView

​		7、HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet

​		8、DispatcherServlet将ModelAndView传给ViewReslover视图解析器

​		9、ViewReslover解析后返回具体View

​		10、DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）

​		11、DispatcherServlet响应用户

## SpringMVC的核心

​		DispatcherServlet		核心控制器

​		HandlerMapping			处理器映射器

​		HandlerAdapter			处理器适配器

​		ModelAndView			数据视图模型对象

​		ViewReslover			视图解析器

## Spring的IOC和AOP以及DI注入

### 		IOC

​			核心：控制反转

​			“控制反转”，不是什么技术，而是一种设计思想 Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。

​			

### 		AOP

​			核心：面向切面

​			面向切面也是一种设计思想，他是为了解决代码混乱，代码冗余

​			AOP的关键点：

​				关注点：

​				切面(Aspect)：是一个类，里面定义了通知与切点。 

​				切点(PointCut)：表达式。就是告诉程序要在执行哪些核心业务的时候，执行非核心的业务。 

​				通知（advice）:



五种通知方式： 



前置通知	[Before advice]：	在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常。 	

​				

正常返回通知[After returning advice]：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行。 		

​	

异常返回通知[After throwing advice]：在连接点抛出异常后执行。 			



返回通知[After (finally) advice]：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容。 	



环绕通知[Around advice]：环绕通知围绕在连接点前后，比如一个方法调用的前后。这是最强大的通知类型，能在方法调用前后自定义一些操作。环绕通知还需要负责决定是继续处理join point(调用ProceedingJoinPoint的proceed方法)还是中断执行。 

### DI

​		依赖注入(DI),DI是IOC的实现方式,依赖注入(DI)和控制反转(IOC)是从不同的角度的描述的同一件事情，就是指通过引入IOC容器，利用依赖关系注入的方式，实现对象之间的解耦。 所谓依赖注入，是指程序运行过程中，如果需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部的注入。Spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持对POJO之间依赖关系的管理 

​		

## Mybatis是什么呢？

​	其实，它底层就是一个JDBC封装的组件 ,MyBatis的前身是Ibatis ,也是一个半自动的ORM关系映射框架

## Mybatis和Hibernate的区别是什么？

​	Mybatis是半自动ORM映射框架，而Hibernate是一个全自动映射框架，Hibernate映射了数据库和实体类的关系，而Mybatis映射了实体类和SQL语句的关系

## Mybatis核心组件有哪些

​	SqlSessionFactoryBuilder（构造器）

​		

​	SqlSessionFactory（工厂接口）

​	SqlSession（会话接口）

​		 作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能 

​	SQL Mapper（映射器）

​		

​	Executor（执行器）

​		MyBatis执行器，是MyBatis 调度的核心，负责SQL语句的生成和查询缓存的维护 



​	StatementHandler（封装了JDBC Statement操作 ）

​		封装了JDBC Statement操作，负责对JDBC statement 的操作，如设置参数、将Statement结果集转换成List集合。 



​	ParameterHandler（参数转换器）

​		  负责对用户传递的参数转换成JDBC Statement 所需要的参数， 



​	ResultSetHandler（结果返回）

​		  负责将JDBC返回的ResultSet结果集对象转换成List类型的集合； 



​	TypeHandler（转换实体类与数据库的映射）

​		  负责java数据类型和jdbc数据类型之间的映射和转换 



​	MappedStatement（维护增删改查节点）

​		MappedStatement维护了一条<select|update|delete|insert>节点的封装，

  

​	SqlSource（sql源生成器）

​		 负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回 



​	BoundSql（生成的sql）

​		表示动态生成的SQL语句以及相应的参数信息 



​	Configuration（Mybatis的所有配置信息）

​		 MyBatis所有的配置信息都维持在Configuration对象之中。 

## Mybatis的运行流程

​	首先SqlSessionFactoryBuilder，根据传入的数据流生成Configuration对象，

​	然后根据Configuration对象创建默认的SqlSessionFactory实例

​	然后从SqlSessionFactory中获取SqlSession

​	然后根据SqlSession去执行Executor执行器

​	在执行的过程中StatementHandler封装参数以及JDBC原生操作

​	ParameterHandler是在StatementHandler封装的参数

​	TypeHandler负责转换实体类和数据库字段的关系

# 微服务相关

## Ribbon的默认负载均衡算法有几种

```
RoundRobinRule			     轮询
```

	RandomRule			         随机
	
	AvailabilityFilteringRule	  会先过滤多次访问故障而处于断路器跳闸状态的服务
	
	WeightedResponseTimeRule 	  根据平均响应时间计算所有的服务权重，响应时间越快服务权重越大就越容易被选中，刚启动时信息统计不足，会先使用轮询，等到响应数据有了之后在进行响应时间进行均衡负载


	RetryRule 					先按照轮询的方式，如果获取到服务失败等就会在指定的时间内进行重试，然后获取下一个可用的服务
	
	BastAvailableRule			 会先过滤掉由于多次访问故障而处于断路器跳闸的服务，然后选择一个并发量最小的服务
	
	ZoneAvoidanceRule		     默认规则，符合判断服务所在的区域的性能和服务的可用性选择服务器

## Eureka和Zookeeper的区别

著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A(可用性)和P(分区容错性) 。

Zookeeper保证CP



​	所以Zookeeper的一致性比较强，但是他的可用性并不高，体现在如果一个Zookeeper集群挂掉了父节点，那么他会重新进行选举，而在这个选举的过程中他是无法提供服务的



Eureka保证AP

​	

​	在Eureka的集群中，他保证了可用性，也就是当一个注册中心挂掉了之后他会带着服务去另一个注册中心，这个并不影响他们的可用性，只要还有一口气他的服务就能提供，除非所有的注册中心都挂掉了

## Eureka的运行流程和实现原理

Register（服务注册）	 ----》 	Renew（服务续约   	----》  	 Cancel（服务下线） 

服务注册一般是发生在服务启动的时候，后面如果服务自身检测认为 Down，也会来更新服务状态的。 

服务续约，主要是用来告诉 Eureka Server Service Provider 还活着，避免服务被剔除掉。 

服务下线一般在 Service Provider shut down 的时候调用，用来把自身的服务从 Eureka Server 中删除，以防客户端调用不存在的服务。 

小结：服务的注册表示服务发现，将自己的信息注册到Eureka上面，并且不定期的发送检测机制（心跳检测），如果有相应就进行服务续约，如果发现一个服务响应超时或者说访问不了，那么他就会将服务剔除掉，这就是服务下线



实现原理：

​		其实主要还是使用Servlet实现的，它使用 Jersey ，框架实现自身的 RESTful HTTP接口，peer之间的同步与服务的注册全部通过 HTTP 协议实现 ，他的心跳机制等都是通过定时任务去进行实现的



## Eureka的核心

### 心跳检测机制

什么是心跳检测机制？

​	就是当你的服务再运行的过程中他会时不时地去检测你当前的服务是否健康如果响应超时或者访问不到它就会进行服务剔除，默认是90秒，这个是可以修改的，但是如果Eureka和服务之间出现了网络故障本来就是由于自己的网络状态所引起的那么他就会进入到自我保护状态

### 自我保护机制

​	自我保护机制的工作机制是如果在15分钟内超过85%的客户端节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，Eureka Server自动进入自我保护机制，此时会出现以下几种情况： 



1、Eureka Server不再从注册列表中移除因为长时间没收到心跳而应该过期的服务。



2、Eureka Server仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上，保证当前节点依然可用。



3、当网络稳定时，当前Eureka Server新的注册信息会被同步到其它节点中。



这里我们可以看到哪怕他是出现了故障的时候他都会保证当前节点的可用性。以及自己的容错性，所以在个Zookeeper的对比中他做到了AP(可用性和分区容错性)

### Eureka服务端配置

```
心跳检测，毫秒，改为10秒，如果10秒没有收到服务的信息，那么就会将服务剔除掉，默认60*1000,60秒
eureka.server.eviction-interval-timer-in-ms=10000

是否开启自我保护，默认true
eureka.server.enable-self-preservation=true

是否将自己注册到注册中心上以供其他服务发现，默认true
eureka.client.register-with-eureka=false

是否从注册中心上，获取注册表的信息
eureka.client.fetch-registry=false

```

### Eureka客户端配置

```
#eureka客户端需要多长时间发送心跳给eureka服务器，表明他仍然或者，默认30秒
eureka.instance.lease-renewal-interval-in-seconds=30

#eureka服务器在接受到实力的最后一次发出的心跳后，需要等待多久才可以将此实例删除，默认90秒
eureka.instance.lease-expiration-duration-in-seconds=30

#表示eureka client间隔多久去拉取服务器注册信息,默认为30秒
eureka.client.registry-fetch-interval-seconds=18

#表示eureka的注册中心的地址
eureka.client.serviceUrl.defaultZone=http://127.0.0.1:8081/eureka/
```

## Feign客户端负载均衡以及熔断

### Feign客户端的实现原理

​    Feign 的英文表意为“假装，伪装，变形”， 是一个http请求调用的轻量级框架，可以以Java接口注解的方式调用Http请求，而不用像Java中通过封装HTTP请求报文的方式直接调用。 他是基于HttpClient进行调用的，

# 项目方面

## 介绍一下自己 

​		首先简短的介绍自己：

​			你好我叫XXX，今年XX岁，面试的职位是XXX，以前在XXXX公司工作过X年，（根据实际情况，说学校以及）

## 讲讲项目经历 

​		结合实际项目或者虚拟项目，划分模块2-3个，每一个模块所应用到的核心技术（如：Redis，Elasticsearch，MongoDB，FastDFS等等），然后是就是项目整体架构（例如：垂直结构（SSM），分布式架构（Dubbo），还有微服务架构（SpringCloud）），然后就是核心的功能，例如搜索，如何去进行搜索，有哪些比较有特点的代码，在做这个搜索模块中所遇到的问题，还有优化和容灾是如何进行，如果让你来设计这个搜索你会如何设计这个模块



## 你们项目中微服务是怎么划分的，划分粒度怎么确定？ 

​		答：这个是根据整体项目的架构大小来确认的，如果功能特别多特别复杂以及业务上面的区分来进行划分，例如：汽车销售平台中的和汽车相关的，在项目比较小的情况下并且业务划分不太多，比如汽车卖出去之后和汽车销售的统计，还有一些不太多的小功能（例如：规格参数和海报），那么这个就完全可以写到一个模块中，就叫做汽车模块，但是另一种场景，他需要汽车表的基本功能，还有统计，然后他还有一个需求，是保险方便的，车险需要购置保险，并且如果还有合同等等，这样的话就需要拆分成两个模块了，一个汽车模块。一个售后附加模块，更多的是根据业务来进行划分的

## 那在实践微服务架构中，有遇到什么问题么？ 

### Docker：

​	1、在使用Docker部署的时候一些特定不开放端口的服务，我们重新启动了Docker，这样会破坏Centos7的firewalld防火墙规则，这样这个端口还是会被访问的，例如我们先启动防火墙然后启动docker进行端口映射这样会造成规则破坏，导致端口号无法被防火墙拦截，造成安全隐患那么怎么解决呢（Centos7中会出现），原因是因为Docker在使用端口

​		解决博客

​		https://myforever.cn/blog/538872310925361152/550244603433844736/551125169477779456

### 数据库：

​	

### 项目：

​	1、Eureka的心跳机制问题，在项目中关闭了Eureka的心跳机制

​				

### 服务器：

​				

### 前后端交互：

​	1、分布式id前端精度丢失问题，在数据库中使用bigint数据类型，在项目实体类中使用Long类型，并且进行分布式id的生成，在前后端的数据传递过程中，由于前段long类型只能保存16位，而分布式id至少有19位，从而造成精度的丢失，而引起的数据不一致性

​	解决方案：

​		将实体类中的分布式字段id改成String类型，并且将分布式id生成改为idwork-str的String类型，这样就能解决了

## 你们在关于微服务间数据一致性问题，是如何解决的？ 

### 数据库方面：

​		在数据库主从复制的时候，所引起的主从延迟问题造成的数据库不一致，那么这个如何解决呢？

​		

## 自己做过哪些调优？JVM调优、数据库调优都行

​	数据库调优，主要是体现在数据库的索引优化上，对一些比较查询频繁的表和数据量比较大的表进行索引的优化，通过结合代码进行索引的创建，并且通过Mysql性能分析进行检查代码性能



​	**方案一：忽略**

​				任何脱离业务的架构设计都是耍流氓，绝大部分业务，例如：百度搜索，淘宝订单，QQ消息，58帖子都允许短时间不一致。如果业务能接受，最推崇此法。别把系统架构搞得太复杂。

​	**方案二：选择性主读**

​				将哪个库，哪个表，哪个主键三个信息拼装一个key设置到cache里，这条记录的超时时间，设置为“主从同步时延” ，画外音：key的格式为“db:table:PK”，假设主从延时为1s，这个key的cache超时时间也为1s。 这是要读哪个库，哪个表，哪个主键的数据呢，也将这三个信息拼装一个key，到cache里去查询， 在cache里记录哪些记录发生过写请求，来路由读主还是读从 



## 平时会用到哪些数据结构？ 

​		线型：

​			数组

​			队列

​			栈

​		树型：

​			B+树

​			红黑树

## RPC和HTTP的关系是什么？ 

​		RPC（即Remote Procedure Call，远程过程调用） 

​		HTTP（HyperText Transfer Protocol，超文本传输协议） 

​		他们最本质的区别，就是RPC主要工作在TCP协议之上，而HTTP服务主要是工作在HTTP协议之上，我们都知道HTTP协议是在传输层协议TCP之上的，所以效率来 说RPC肯定是要比HTTP效率更高得

## 谈一谈你对微服务架构的理解 

​		主要是因为SOA（流式计算架构），微服务架构我们可以看成流式计算，并且将相应的功能模块拆分成一个个细微的服务，服务与服务之间可以相互调用，并且微服务可以很好的实现扩容缩容，Cloud也提供了一系列的技术解决方案，能够协调这些服务进行项目的构建以及运维

SpringCloudAlibaba

## 你用过哪些RPC框架，讲讲他们优缺点 

​		Dubbo，只支持JAVA语言，不能支持其他语言的拓展，Dubbo只是实现了服务治理，其他组件需要另外整合以实现对应的功能，比如，分布式配置：可以使用淘宝的diamond、百度的disconf来实现分布式配置管理。服务跟踪：可以使用京东开源的Hydra，批量任务：可以使用当当开源的Elastic-Job，Dubbo的RPC来实现服务间调用的一些痛点，服务提供方与调用方接口依赖方式太强：调用方对提供方的抽象接口存在强依赖关系，需要严格的管理版本依赖，才不会出现服务方与调用方的不一致导致应用无法编译成功等一系列问题 ，服务对平台敏感，难以简单复用：通常我们在提供对外服务时，都会以REST的方式提供出去，这样可以实现跨平台的特点。 在Dubbo中我们要提供REST接口时，不得不实现一层代理，用来将RPC接口转换成REST接口进行对外发布。 

​		总结：

​				只支持Java不易于拓展

​				组件少，整合繁琐，对项目的构建来说难度会比较大

​				对接口的依赖高，并且需要严格的管理版本依赖

​				服务对平台敏感，难以简单复用：通常我们在提供对外服务时通常以REST方式提供

## 用过docker么，对容器了解多少 

​		简单的了解和使用过，docker是一个容器虚拟化技术，他的三个核心是，镜像，容器，仓库，从仓库中下载镜像再通过镜像虚拟化容器到宿主机中，解决了开发环境的不一致的问题，并且他轻巧方便，并且有极高的稳定性



## 如何定位JAVA生产卡顿或卡死问题，如何定位解决问题

​		首先在Linux当中定位问题

​		首先查询是不是Java的问题导致的占用内存过高

![](img\top.png)

```
top
```

​		那么我们查看例如4087（他只占用了0.7的CPU，但是生产的时候定位的时候肯定不是，模拟环境）

​		我们就定位到了4087他占用CPU就是这个Java进程，然后我们分析这个进程的线程

```
ps -mp 4087 -o THREAD,tid,time
```

![](img\thread.png)

​	我们可以看到线程的tid，我们找到例如4185这个线程，那么在内存中使用的是16进制，所以我们需要转换为16，把4185用计算器或者其他的转换为16进制，那么4185转换为16进制就是1059 ，但是在分析的时候需要使用字母必须为小写

jstack 4087 | grep 1059 -A60

然后通过进程id再跟踪线程tid进行分析

​	![](img\分析.png)

这样就能找到对应的线程以及对应的类，以及错误行数了，然后进行代码的修改或者是优化