# **多线程**

## 关于HashMap，HashSet，和ArrayList集合的线程安全以及解决方案

​		其实HashMap，HashSet，和ArrayList接口的这些都是线程不安全的，他们在多线程操作的时候都会产生线程安全的问题，具体体现在多线程的添加的时候都会出现ConcurrentModificationException这个异常，那是由于多线程的修改同一个数据引起的

那么如何解决呢

解决ArrayList可以使用的方法

```
使用Vector修饰
List<String> map = new Vector<>();

使用Collections的工具类给List上锁
List<String> map = Collections.synchronizedList(new ArrayList<>());

使用JUC工具包CopyOnWriteArrayList的写时复制List
List<String> map = new CopyOnWriteArrayList<>();
```

解决HashMap的问题

```
使用Collections的工具类给Map上锁
Map<String,Object> hash = Collections.synchronizedMap(new HashMap<>());

使用ConcurrentHashMap并发工具包
Map<String,Object> hash = new ConcurrentHashMap<>();
```

解决HashSet的问题

```
使用Collections的工具类给Set上锁
Set<String> set = Collections.synchronizedSet(new HashSet<>());

使用JUC工具包CopyOnWriteArraySet的写时复制List
Set<String> set = new CopyOnWriteArraySet<>();
```

 

## 怎么检测一个线程是否拥有锁

​	java.lang.Thread中有一个方法叫holdsLock() ，返回true表示当前线程有锁

## 同步和异步有什么区别

同步异步通常形容方法的调用过程

同步：

​    	同步就是方法的执行必须有序，也就是我调用一个方法，这个方法必须执行完我才能继续执行；即有序执行 

异步：

​	异步就是在方法调用的时候不用等待也能执行其他的方法，例如我在调用一个方法时我还能调用其他的方法，不必等待前面的方法执行完再执行下一个

## 并发、并行有什么区别

​	并发：多个任务轮流争取CPU的资源，多个任务交替执行，看起来好像多个程序一起执行其实还是多个任务在共享一个CPU

​	并行：每个线程使用一个CPU，真正的一起执行 

## 临界区（锁，资源争抢）

​	表示一个公共资源或者共享数据，可以被多个线程使用;每一次，只能有一个线程使用它，一旦临界区资源被专用(加锁)，其他线程想要使用这个资源，就必须等待； 

## 阻塞、非阻塞有什么区别

​	阻塞：当一个线程占用了临界资源（被上锁的临界资源），那么当其他线程想要访问临界资源的时候，就必须等待，等待会导致线程挂起，即将当前线程放入到等待队列中，直到被唤醒； 

​	非阻塞：线程之间的执行不受共享资源的状态影响，即不会被挂起； 

## 线程之间的锁机制会引发哪些问题

​	死锁：线程间相互的调用，所引起的锁资源获取不到导致无限等待循环，例如A需要执行B后才能释放锁，C需要执行A后释放锁，B有需要C执行后释放锁，导致锁释放不出来。没人拿的到这个锁造成的死锁

​	活锁：两个线程互相主动将资源释放，让给对方，但没有一个线程可以同时拿到所有资源而正常执行 

​	饥饿： 线程因为某种原因(例如线程的优先级比较低)一直等待资源，无法获取所需要的资源，导致一直无法执行 

## 进程，线程的区别是什么

​	进程：是系统进行资源分配和调度的基本单位，进程是基本执行的实体，是线程的容器，运行一个程序，就相当于运行一个进程。当我们程序有很多小的任务需要执行的时候，我们使用进程进行任务之间的切换，比较费时，且数据交换麻烦，因此引入线程 

​	线程：是程序执行的最小单位，线程之间可共享数据，线程之间切换的成本较低，一个进程包含很多线程； 

## 多线程的一些性质

​	原子性：Atomicity 

​		原子性指的是一个操作不可能被中断，即如果多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰； 

​	可见性：Visibility 

​		可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改；对于串行来说，不存在这个问题，此问题只针对于并行； 

​	有序性：Ordering 

​		当程序执行时，有可能会进行指令重拍，重拍后的指令和原指令的顺序未必一致； 

## 线程的状态有哪些

​	创建New

​		新建状态表示刚刚创立的简称，这个线程还没有开始执行，需要等到start()方法调用时，才表示线程执行； 

​	启动Runnable

​		运行状态表示线程所需的一些资源都已经准备好了，可以执行 

​	阻塞Blocked

​		阻塞状态，表示当遇到Synchronized同步块是，就会进行blocked阻塞状态，这个线程会暂停执行，直到获取请求的锁 

​	停止Waiting

​		Waiting/Time Waiting:Waiting等待状态会进入一个无时间限制的等待 

​		Time_Waiting会进行一个有时间的等待； 

​	结束Terminated

​	有限等待Time_Waiting 

## 线程有哪些方法

终止线程stop()

线程中断lnterrupt()

睡眠sleep()

等待wait(),notify()

挂起suspend()

等待线程结束join()、谦让yield()： 

synchronized关键字 

## Java实现多线程有哪几种方式

​		有四种

​				1、继承Thread类

​				2、实现Runnable接口

​				3、实现Callable接口

​				4、线程池

## Callable和Future的了解

​		Callable接口代表一段可以调用并返回结果的代码 

​		Future接口表示异步任务，是还没有完成的任务给出的未来结果 

​		所以说Callable用于产生结果，Future用于获取结果。 

### 线程池的接口和依赖的关系

​	Executor				父类接口

​	ExecutorService			继承Executor

​	AbstractExecutorService	实现ExecutorService

​	ThreadPoolExecutor 		继承AbstractExecutorService

### 线程池的几个参数

int corePoolSize							//核心线程数,允许同时执行任务的最大线程数

int maximumPoolSize						// 最大线程数，允许同时处理任务的最大线程数

long keepAliveTime						// 超出核心线程数的空闲线程的最大存活时间

TimeUnit unit							//空闲线程存活时间单位

BlockingQueue<Runnable> workQueue		// 阻塞任务队列，存储待执行的任务

ThreadFactory threadFactory				// 线程工厂，用于创建线程，可指定线程命名规则

RejectedExecutionHandler handler			// 饱和策略(拒绝策略)，当线程池阻塞队列已满时对新任务的处理

​	ThreadPoolExecutor.AbortPolicy;		//丢弃任务并抛出RejectedExecutionException异常。 			

​	ThreadPoolExecutor.DiscardPolicy;		//也是丢弃任务，但是不抛出异常。 		

​	ThreadPoolExecutor.DiscardOldestPolicy;//丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）

​	ThreadPoolExecutor.CallerRunsPolicy;	//由调用线程处理该任务 

### 常见的线程池有哪几种

​	**1. newSingleThreadExecutor** 



​		创建一个单线程的线程池。这个线程池仅仅有一个线程在工作，也就是相当于单线程串行运行全部任务。假设这个唯一的线程由于异常结束，那么会有一个新的线程来替代它。此线程池保证全部任务的运行顺序依照任务的提交顺序运行。 



​	**2. newFixedThreadPool** 



​		创建固定大小的线程池。每次提交一个任务就创建一个线程。直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变。假设某个线程由于运行异常而结束，那么线程池会补充一个新线程。 



​	**3. newCachedThreadPool** 



​		创建一个可缓存的线程池。假设线程池的大小超过了处理任务所须要的线程.那么就会回收部分空暇（60秒不运行任务）的线程，当任务数添加时。此线程池又可以智能的加入新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小全然依赖于操作系统（或者说JVM）可以创建的最大线程大小。



​	**4. newScheduledThreadPool** 

​		创建一个大小无限的线程池。此线程池支持定时以及周期性运行任务的需求。

## 如何自定义一个线程池

​	首先是我们要知道线程池的核心是什么其实就是从ThreadPoolExecutor中创建来的，那么我们来看一下ThreadPoolExecutor的使用，分别介绍了他的7个参数以及用法，首先

5											是核心线程数

10											是最大线程数（最大线程数中包含核心线程数）

3L											表示超时时间3，单位不确定

TimeUnit.MICROSECONDS						表示超时时间单位						

​	TimeUnit.DAYS          			 //天  
	TimeUnit.HOURS        			 //小时  
	TimeUnit.MINUTES      		 //分钟  
	TimeUnit.SECONDS      		 //秒  
	TimeUnit.MILLISECONDS  		 //毫秒 
	TimeUnit.NANOSECONDS   	 //毫微秒

​	TimeUnit.MICROSECONDS  	//微秒

 Executors.defaultThreadFactory()				使用Executors默认的线程工厂

new LinkedBlockingQueue<>(30)				阻塞队列长度为30，一个项目的最大并发数就是最大线程数+阻塞队列数

​			常用的三个阻塞队列（一共）

​			SynchronousQueue			单个阻塞队列

​			ArrayBlockingQueue			由数组构建的有界的阻塞队列

​			LinkedBlockingQueue			由链表构建的无界的阻塞队列（默认为Integer的max值也就是21亿，不推荐直接使用最大值）

new ThreadPoolExecutor.CallerRunsPolicy()		拒绝策略

​			ThreadPoolExecutor.AbortPolicy;	 	如果超过了阻塞队列+最大线程池的数量的并发抛出异常 			

​			ThreadPoolExecutor.DiscardPolicy;		如果超过了阻塞队列+最大线程池的数量的并发直接丢弃

​			ThreadPoolExecutor.DiscardOldestPolicy如果超过了阻塞队列+最大线程池的数量的并发丢弃最前面的尝试执行下一个线程，也就是超过的有可能被执行一次

​			ThreadPoolExecutor.CallerRunsPolicy	如果超过了阻塞队列+最大线程池的数量的并发如果自己处理不了那么交给调用的线程执行，也就是main线程调用线程池，但是超过了，那么线程池处理不了交给main线程进行执行

```
        Executor executor = new ThreadPoolExecutor(
                5,
                10,
                3L,
                TimeUnit.MICROSECONDS,
                new LinkedBlockingQueue<>(30),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy());
```

​	这个就是自定线程池的过程，那么我们来介绍如何合理的设置线程池参数

### 合理线程池参数定制

​	CPU密集型

​		由于要保证线程的计算速度也就是高利用CPU的性能

​		计算模式

​			（注：单核CPU告辞）

​			CPU核数+1

​	IO密集型

​		分两种

​			CPU * 2		(推荐第二种)

​			CPU / 1  - 阻塞系数	阻塞系数为0.8-0.9

## 使用无界阻塞队列会出现什么问题？

## 什么是JMM

​	JMM就是Java的内存模型

## 什么是CAS

​	CAS是英文单词Compare and Swap的缩写，翻译过来就是比较并替换 ，CAS是一种有名的无锁算法，那么它是如何实现无锁的呢，既然我们上面提到了CAS的翻译，那么肯定就是比较并且替换，在许多并发容器中有使用到，例如AtomicInteger，那么它是如何实现的呢？下面我们通过白话文来概述CAS的无锁机制

​	白话文：

​		CAS的无锁采用比较并替换，那么什么是比较并替换呢，我们假设一个数据的值为1，我们现在需要对他进行++的操作，那么我们拿到1，再拿到1+1，我们设置，在设置的时候我们会多传入一个参数，这个参数就是1，也就是我当前从主内存中获取到的内存，我们拿这个1去比较主内存中的数据，1=1，那么条件为true，这时我们就会去进行修改。将1修改为1+1，那么同时有另一个线程也从主内存中拿到了1，但是现在1已经被第一条线程修改为2了，那么另一条线程从主内存中获取到的1，他回去拿1进行比较，这个时候比较结果为false，修改失败，代码示例如下

​	我们可以看到如下代码执行时第一次修改成功第二次修改失败

```
    @Test
    public void testCas(){
        AtomicInteger atomicInteger = new AtomicInteger(1);

        boolean a = atomicInteger.compareAndSet(1, atomicInteger.get() + 1);
        boolean b = atomicInteger.compareAndSet(1, atomicInteger.get() + 1);

        System.out.println("第一次修改结果为：" + a + "，值为：" + atomicInteger.get());
        System.out.println("第二次修改结果为：" + b + "，值为：" + atomicInteger.get());
    }
```

​	那么是不是会有同学会疑问，那么这个值我们怎么才能保证当前取出来的是最新的呢，不用担心我们点进去看AtomicInteger的源码我们会发现，他的value是使用volatile关键字进行修饰的，也就是说他拿到的是主物理内存最新的数据，我们再来修改，这次我们的1采用atomicInteger进行获取，代码示例如下，喜欢测试的同学可以启用多条线程同时去修改atomicInteger测试

```
@Test
public void testCas(){
    AtomicInteger atomicInteger = new AtomicInteger(1);
    boolean a = atomicInteger.compareAndSet(1, atomicInteger.get() + 1);
    System.out.println("第一次修改结果为：" + a + "，值为：" + atomicInteger.get());
    boolean b = atomicInteger.compareAndSet(atomicInteger.get(), atomicInteger.get() + 1);
    System.out.println("第二次修改结果为：" + b + "，值为：" + atomicInteger.get());
}
```

## CAS以及UnSafe类

​		由于我们CAS在操作数据的时候，是直接修改主物理内存的地址的，而Java并没有提供直接修改主物理内存的方式，但是我们可以通过UnSafe的native 本地方法进行修改，Unsafe的大部分API都是native的方法，主要包括以下几类： 

​		Class相关。主要提供Class和它的静态字段的操作方法。

​		Object相关。主要提供Object和它的字段的操作方法。

​		Arrray相关。主要提供数组及其中元素的操作方法。

​		并发相关。主要提供低级别同步原语，如CAS、线程调度、volatile、内存屏障等。

​		Memory相关。提供了直接内存访问方法（绕过Java堆直接操作本地内存），可做到像C一样自由利用系统内存资源。

​		系统相关。主要返回某些低级别的内存信息，如地址大小、内存页大小。

​		我们在Jvm中提到过native的本地方法栈，封装了很多操作系统，以及内存和其他的拓展

## 自定义CAS并发容器

​		在其他的实现中都是别人封装好的Atomic原子类，那么我们现在有一个自己的实体类该如何封装呢？

​		其实非常简单，我们只需要使用一个引用就行了，下面以User类为示例

```
    @Test
    public void testCas(){
        AtomicReference<User> atomicReference = new AtomicReference<>();
        User a = new User();
        User b = new User();
        atomicReference.set(a);
        atomicReference.compareAndSet(a, b);
    }

```

## CAS的缺点

​	1、一直修改失败，导致时间过长，消耗CPU

​		在多线程的情况下，多个线程同时抢占，每次修改时其他线程总比一个或者多个线程先一步执行，如果长时间都没有修改成功对CPU的消耗比较大，会占用CPU空间

​	2、多变量原子操作

​		对多个共享变量进行操作时CAS就无法保证操作的原子性了，他只保证当前的比较对象的原子操作

​	3、ABA问题

​		在多线程环境中，使用 CAS，如果一个线程对变量修改 2 次，第 2 次修改后的值和第 1 次修改前的值相同，其他线程对此一无所知，这类现象称为 ABA 问题 ，下面这个例子可以帮助我们解决ABA问题

## CAS的ABA问题解决

​		我们使用AtomicStampedReference，通过原子引用比较，并且加上版本号来进行识别

```
    @Test
    public void testCas(){
        AtomicStampedReference<Integer> a = new AtomicStampedReference<>(100,0 );
        //第一次设置，设置为+1，同时版本号加一
        a.set(a.getReference()+1,a.getStamp()+1 );
        System.out.println("第一次设置值，设置成功,值为：" + a.getReference() + ",版本号为" + a.getStamp());
        //第二次设置，100 ！= 101，值比较失败，修改失败
        boolean one = a.compareAndSet(100, 102, a.getStamp(), a.getStamp()+1);
        System.out.println("第二次设置值，设置" + (one ? "成功":"失败") + ",值为：" + a.getReference() + ",版本号为" + a.getStamp());
        //第三次设置，101 == 101，版本号以及值都相等，修改成功，版本号+1
        boolean two = a.compareAndSet(101, 102, a.getStamp(), a.getStamp()+1);
        System.out.println("第三次设置值，设置" + (two ? "成功":"失败") + ",值为：" + a.getReference() + ",版本号为" + a.getStamp());
        System.out.println("最后值为：" + a.getReference() + ",版本号为：" + a.getStamp());
    }
```

## volitile关键字的作用

​		他是一个轻量级的同步机制，保证内存可见性（Memory Visibility）常用于保持内存可见性和防止指令重排序。 所有线程都能看到共享内存的最新状态，但是他不保证原子性。

```
public class MutableInteger {
    private int value;
    public int get(){
        return value;
    }
    public void set(int value){
        this.value = value;
    }
}

MutableInteger不是线程安全的，因为get和set方法都是在没有同步的情况下进行的。如果线程1调用了set方法，那么正在调用的get的线程2可能会看到更新后的value值，也可能看不到。

```

Java通过几种原子操作完成`工作内存`和`主内存`的交互 

1. lock：作用于主内存，把变量标识为线程独占状态。
2. unlock：作用于主内存，解除独占状态。
3. read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。
4. load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。
5. use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。
6. assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。
7. store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。
8. write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。

### volatile如何保持内存可见性

volatile的特殊规则就是：

- read、load、use动作必须**连续出现**。
- assign、store、write动作必须**连续出现**。

所以，使用volatile变量能够保证:

- 每次`读取前`必须先从主内存刷新最新的值。
- 每次`写入后`必须立即同步回主内存当中。

也就是说，**volatile关键字修饰的变量看到的随时是自己的最新值**。线程1中对变量v的最新修改，对线程2是可见的。 

volatile解析

https://www.cnblogs.com/monkeysayhi/p/7654460.html

## synchronized关键字的用法，优缺点

​		可以用在代码块上，还有方法上面，synchronized 粒度有些大，在处理实际问题时存在诸多局限性。

## sleep和wait的区别

​		sleep是睡眠，他指定了一个时间，他会时刻的监视这个时间如果一旦到达就会继续运行，但是wait的睡眠他会让进入到一个类似等待池的状态，在这个状态中他是真正的睡眠，如果不去唤醒他会一直进入到休眠，这个时候就需要唤醒了，我们可以使用notify（在只有两个线程时）他会被其他线程唤醒，但是如果多个线程都在睡眠，这个情况下使用notify就不一定有效了，那么我们可以使用notifyall

## notify和notifyall的区别

​		notify是唤醒一个线程，这个线程并不能我们指定的去唤醒，但是他会让正在休眠的线程中的某一个线程唤醒，而notifyall则是让所有的睡眠的线程进行唤醒

# 锁相关

## Lock接口有哪些实现类，使用场景是什么

​		Lock有三个实现类

​			ReentrantLock （可重入锁）

​			ReentrantReadWriteLock.ReadLock（读锁）

​			ReentrantReadWriteLock.WriteLock（写锁）

## 可重入锁的用处及实现原理

### 什么是可重入锁

​	可重入锁ReentrantLock，他是一个可重入锁，他指的是同一线程外层获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也就是说，线程可以进入任何一个它已经拥有锁的锁同步者的代码块

​	注：（synchronized也是一个可重入锁）

​	注：（一个线程，线程调用A方法A方法中调用到B方法）我们可以这样理解，两个方法都用到了锁，A方法调用B方法，他们使用的是同一个锁，那么我们使用可重入锁，A拿到锁执行到B进入B方法，那么这个时候他就回去自动获取这个锁，通常这个锁是会等他放开了我们才能拿到，现在我们可以直接自动拿到并执行，然后执行完毕B方法执行完了，这个栈就开始出栈了，他会返回到A然后A执行完毕，它的作用是为了防止死锁

​		同时他实现了公平锁和非公平锁，可以通过他的构造方法来进行指定

```
        ReentrantLock nonfairSync = new ReentrantLock(false);
        ReentrantLock fairSync = new ReentrantLock(true);
```

​		具体体现在他的构造方法中，它默认使用的非公平锁

​		![](img/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png)

​	并且默认的构造方法是非公平锁

​	![](img/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png)

### 什么是公平锁

​	公平锁表示线程公平，按序执行，并且保证原子性

```
import java.util.concurrent.locks.ReentrantLock;

public class MyFairLock {
    /**
     *     true 表示 ReentrantLock 的公平锁
     */
    private  ReentrantLock lock = new ReentrantLock(true);

    public   void testFail(){
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName() +"获得了锁");
        }finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {
        MyFairLock fairLock = new MyFairLock();
        Runnable runnable = () -> {
            System.out.println(Thread.currentThread().getName()+"启动");
            fairLock.testFail();
        };
        Thread[] threadArray = new Thread[10];
        for (int i=0; i<10; i++) {
            threadArray[i] = new Thread(runnable);
        }
        for (int i=0; i<10; i++) {
            threadArray[i].start();
        }
    }
}
```

输出结果

![](img/%E5%85%AC%E5%B9%B3%E9%94%81.png)

​		这样的话那么他就是一个公平锁我们可以

### 什么是非公平锁

非公平锁不保证公平性，不会刻意去控制线程，但是性能高

```
public class MyNonfairLock {
    /**
     *     false 表示 ReentrantLock 的非公平锁
     */
    private  ReentrantLock lock = new ReentrantLock(false);

    public  void testFail(){
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName() +"获得了锁");
        }finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {
        MyNonfairLock nonfairLock = new MyNonfairLock();
        Runnable runnable = () -> {
            System.out.println(Thread.currentThread().getName()+"启动");
            nonfairLock.testFail();
        };
        Thread[] threadArray = new Thread[10];
        for (int i=0; i<10; i++) {
            threadArray[i] = new Thread(runnable);
        }
        for (int i=0; i<10; i++) {
            threadArray[i].start();
        }
    }
}
```

![](img/%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81.png)

### 多层可重入锁

​	如果在一段代码中使用了多层lock上锁，那么会出现什么问题呢？

​	答：如果使用了多层lock，他既不会编译失败也不会运行失败，但是如果我们上了3层锁只解开了两层那么就会导致线程僵死

## 自旋锁

​	这里就和前面的CAS有一点类似了，我们知道CAS他会去不停的请求比较并且修改，那么如果在多个线程的情况中，会产生一个问题，如果我一直修改不到，比如100个线程修改，第一个修改完了，其他线程去修改，现在有一个非常倒霉的线程，他一直修改不了，其他99条线程在一直修改，那么他就会一直循环，这个状态我们叫做自旋，当其他的99条修改完成之后，他才拿到最新的数据并且修改完成

## 读写锁

​		读写锁分读锁和写锁，读锁又被成为共享锁，写锁被称为独占锁，意思就是读锁是共享的我们都能读，写锁被称为独占锁，也就是写的时候我们只能一个人去进行写操作。如果我们直接使用synchronized那就会锁住整个块，不论你是读取还是写入都会加锁，那么这样大大影响了效率，因为我们在写入的时候需要保证安全，而在读取数据的时候我们一般来说并不需要加锁所以就产生了读写锁

​		下面为读写锁的使用

```
        //创建读写锁对象
        ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
        //使用写锁
        try {
            reentrantReadWriteLock.writeLock().lock();
            //逻辑业务代码
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            reentrantReadWriteLock.writeLock().unlock();
        }

        //使用读锁
        try {
            reentrantReadWriteLock.readLock().lock();
            //逻辑业务代码
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            reentrantReadWriteLock.readLock().unlock();
        }
```

## 线程的状态都有哪些

​		创建   

​		准备

​		运行或者阻塞

​		死亡

​		一共有5个状态

# JUC工具类

## **AbstractQueuedSynchronizer**（AQS）（JUC并发包实现的基类）

AbstractQueuedSynchronizer的使用依靠继承来完成，子类通过继承自AQS并实现所需的方法来管理同步状态。

提供了一个基于FIFO队列，可以用于构建锁或者其他同步装置的基础框架 

AQS可以同时实现排它锁和共享锁模式

使用方法是继承，子类通过继承并通过实现它的方法管理其状态｛acquire 和release｝的方法操纵状态

## CountDownLatch

​		下面以CountDownLatch为例子，做一个杀提莫游戏，下面是没有使用CountDownLatch的代码

```
    public static void main(String[] args) {
        //循环10个线程，每一个线程都杀一个提莫
        for (int i = 0; i < 10; i++) {
            new Thread( () -> {
                System.out.println("正在杀第"+Thread.currentThread().getName()+"个提莫");
            },String.valueOf(i+1)).start();
        }
        System.out.println("已经杀完提莫");
    }
```

​	然后我们就会看到，他并没有执行完线程，就打印出了杀提莫（每次执行情况不一致）

![](img\countdownlatch——1.png)

然后我们再来看看使用了CountDownLatch的代码

```
    public static void main(String[] args) {
        //创建CountDownLatch对象，并且初始化10个单位
        CountDownLatch countDownLatch = new CountDownLatch(10);
        //循环10个线程，每一个线程都杀一个提莫
        for (int i = 0; i < 10; i++) {
            new Thread( () -> {
                System.out.println("正在杀第"+Thread.currentThread().getName()+"个提莫");
                //杀完后countDownLatch计数countDown一下
                countDownLatch.countDown();
            },String.valueOf(i+1)).start();
        }
        try {
            //线程等待，等待计数完成释放线程
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("已经杀完提莫");
    }
```

然后我们可以看到，他已经执行了，并且成功的在杀完之后才去进行提示，无论我们执行多少次他都是在杀完了之后才执行的

![](img\countdownlatch——2.png)



## CyclicBarrier

​		CyclicBarrier简介，CyclicBarrier是一个同步辅助类，它允许一组线程相互等待直到所有线程都到达一个公共的屏障点 在程序中有固定数量的线程，这些线程有时候必须等待彼此，这种情况下，使用CyclicBarrier很有帮助，这个屏障之所以用循环修饰，是因为在所有的线程释放彼此之后，这个屏障是可以重新使用的，我们知道CountDownLatch是做计数减少的，而CyclicBarrier是增量到一定数释放的，那么我们来看一下收集龙珠的例子吧

​		下面是一个没有使用CyclicBarrier收集龙珠例子

```
    public static void main(String[] args) {
        for (int i = 0; i < 7; i++) {
            new Thread(() -> {
                System.out.println("收集第"+ Thread.currentThread().getName()+"颗龙珠");
            },String.valueOf(i+1)).start();
        }
        System.out.println("集齐7颗龙珠");
    }
```

​		我们可以看到打印的结果，还没有集齐7颗龙珠就打印了

![](img\cyclicBarrier——1.png)

​		我们再来看一下使用了CyclicBarrier的例子

```
    public static void main(String[] args) {
        //创建CyclicBarrier，收集到7颗之后执行的线程，也可以不执行
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,() -> {
            System.out.println("集齐7颗龙珠");
        });
        //创建线程收集7颗龙珠
        for (int i = 0; i < 7; i++) {
            new Thread(() -> {
                System.out.println("收集第"+ Thread.currentThread().getName()+"颗龙珠");
                try {
                    //cyclicBarrier每次await增量+1
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println("退还第"+ Thread.currentThread().getName()+"颗龙珠");
            },String.valueOf(i+1)).start();
        }
    }
```

​		我们可以看到使用了CyclicBarrier的例子，先是收集了7颗龙珠，然后集齐，然后在await之后然后退还

![](img\cyclicBarrier——2.png)

## Semaphore

​		Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。 从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯，比如XX马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入XX马路，但是如果前一百辆中有五辆车已经离开了XX马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。 

​		我们可以把他当成一个池子，只能有30个人游泳，如果来了40个人，那么进去30个，剩下的10个等着，游泳池的人走一个，然后后面的人进一个

​		应用场景：

​			Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。 

​	

## CyclicBarrier和CountDownLatch的区别是什么？

​		CountDownLatch，使用的是减计数的方式，计算为0时释放所有等待的线程，计数为0时无法重置，调用countDown方法进行计数减一，调用await方法进行阻塞，对计数没有任何的影响

​		CyclicBarrier，使用的是加计数的方式，计数达到指定值时释放，计数重置为0重新开始，调用await时+1，如果加1不等于构造方法的值则线程阻塞，他是可重复利用的，它可以通过它的reset方法来重置，而CountDownLatch使用了就没了

### 

# Java的并发容器有哪些？哪些是同步容器哪些是并发容器

