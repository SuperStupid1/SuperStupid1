# **多线程**

### 关于HashMap，HashSet，和ArrayList集合的线程安全以及解决方案

​		其实HashMap，HashSet，和ArrayList接口的这些都是线程不安全的，他们在多线程操作的时候都会产生线程安全的问题，具体体现在多线程的添加的时候都会出现ConcurrentModificationException这个异常，那是由于多线程的修改同一个数据引起的

那么如何解决呢

​		解决ArrayList可以使用的方法

```java
// 使用Vector修饰
List<String> map = new Vector<>();

// 使用Collections的工具类给List上锁
List<String> map = Collections.synchronizedList(new ArrayList<>());

// 使用JUC工具包CopyOnWriteArrayList的写时复制List
List<String> map = new CopyOnWriteArrayList<>();
```

​		解决HashMap的问题

```java
// 使用Collections的工具类给Map上锁
Map<String,Object> hash = Collections.synchronizedMap(new HashMap<>());

// 使用ConcurrentHashMap并发工具包
Map<String,Object> hash = new ConcurrentHashMap<>();
```

​		解决HashSet的问题

```java
// 使用Collections的工具类给Set上锁
Set<String> set = Collections.synchronizedSet(new HashSet<>());

// 使用JUC工具包CopyOnWriteArraySet的写时复制List
Set<String> set = new CopyOnWriteArraySet<>();
```

 

### 怎么检测一个线程是否拥有锁

​		针对于当前线程来说我们可以检测synchronized关键字来进行加锁的代码进行判断是否有锁

```java
    public static void main(String[] args) {
        Object lock = new Object();
        synchronized (lock){
            hasLock(lock);
        }
        hasLock(lock);
    }

    /**
     * 判断当前线程是否有锁
     * @param object
     * @return
     */
    public static boolean hasLock(Object object){
        boolean flag = Thread.holdsLock(object);
        if(flag){
            System.out.println("有锁");
        }else {
            System.out.println("无锁");
        }
        return flag;
    }
```

​				

### 同步和异步有什么区别

​		同步异步通常形容方法的调用过程

​			同步：

​    				同步就是方法的执行必须有序，也就是我调用一个方法，这个方法必须执行完我才能继续执行；即有序执行 

​			异步：

​					异步就是在方法调用的时候不用等待也能执行其他的方法，例如我在调用一个方法时我还能调用其他的方法，不必等待前面的方法执行完再执行下一个

​		简单的来说就是同步表示做所有的事都要按照顺序等待执行，例如吃火锅排队，但是我们又想上厕所，传统的同步我们需要站在那里排队等待，然后排完队排到桌号就去上厕所，但是异步的话我们可以先取号，然后我们就去上厕所，等他叫到我们之后我们拿着号就能排桌，相当于我们不需要一直等待着，我们可以异步的去上厕所，然后回来查看是否到我们了。



### 并发、并行有什么区别

​	首先我们需要了解并发与并行是如何发生的，并发与并行都是在多线程的情况下发生的。

​		并发：

```
多个任务轮流争取CPU的资源，多个任务交替执行，看起来好像多个程序一起执行其实还是多个任务在共享一个CPU
```

​			示例图如下所示：		

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/1603765917773.png)

​		并行：

```
每个线程使用一个CPU，真正的一起执行
```

​			示例图如下所示：

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/1603766026893.png)

### 临界区（锁，资源争抢）

​	表示一个公共资源或者共享数据，可以被多个线程使用;每一次，只能有一个线程使用它，一旦临界区资源被专用(加锁)，其他线程想要使用这个资源，就必须等待； 

### 阻塞、非阻塞有什么区别

​	阻塞：当一个线程占用了临界资源（被上锁的临界资源），那么当其他线程想要访问临界资源的时候，就必须等待，等待会导致线程挂起，即将当前线程放入到等待队列中，直到被唤醒； 

​	非阻塞：线程之间的执行不受共享资源的状态影响，即不会被挂起； 

### 线程之间的锁机制会引发哪些问题

​	死锁：线程间相互的调用，所引起的锁资源获取不到导致无限等待循环，例如A需要执行B后才能释放锁，C需要执行A后释放锁，B有需要C执行后释放锁，导致锁释放不出来。没人拿的到这个锁造成的死锁

​	活锁：两个线程互相主动将资源释放，让给对方，但没有一个线程可以同时拿到所有资源而正常执行 

​	饥饿： 线程因为某种原因(例如线程的优先级比较低)一直等待资源，无法获取所需要的资源，导致一直无法执行 

### 进程，线程的区别是什么

​	进程：是系统进行资源分配和调度的基本单位，进程是基本执行的实体，是线程的容器，运行一个程序，就相当于运行一个进程。当我们程序有很多小的任务需要执行的时候，我们使用进程进行任务之间的切换，比较费时，且数据交换麻烦，因此引入线程 

​	线程：是程序执行的最小单位，线程之间可共享数据，线程之间切换的成本较低，一个进程包含很多线程； 

### 多线程的一些性质

原子性：Atomicity 

	原子性指的是一个操作不可能被中断，即如果多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰； 
可见性：Visibility 

```
可见性是指当一个线程修改了某一个共享变量的值，其他线程是否能够立即知道这个修改；对于串行来说，不存在这个问题，此问题只针对于并行； 
```

有序性：Ordering 

```
当程序执行时，有可能会进行指令重拍，重拍后的指令和原指令的顺序未必一致；
```

### 线程的状态有哪些

​		线程的状态共分为6种

```
创建New

​		新建状态表示刚刚创立的简称，这个线程还没有开始执行，需要等到start()方法调用时，才表示线程执行； 

启动Runnable

​		运行状态表示线程所需的一些资源都已经准备好了，可以执行 

阻塞Blocked

​		阻塞状态，表示当遇到Synchronized同步块是，就会进行blocked阻塞状态，这个线程会暂停执行，直到获取请求的锁 

停止Waiting

​		Waiting等待状态会进入一个无时间限制的等待 


有限等待Time_Waiting 

​		Time_Waiting会进行一个有时间的等待； 

结束Terminated

​		Time_Waiting表示线程已经终止，运行完毕或者
```

​		这个线程状态可以在java.lang.Thread.State这个类中找到，他是Thread类的一个内部枚举，去掉注释后如下：

```java
    public enum State {
    		/**
    		 * 创建
    		 */
        NEW,
        /**
    		 * 运行
    		 */
        RUNNABLE,
        /**
    		 * 阻塞
    		 */
        BLOCKED,
        /**
    		 * 等待
    		 */
        WAITING,
        /**
    		 * 时间等待
    		 */
        TIMED_WAITING,
        /**
    		 * 终止
    		 */
        TERMINATED;
    }
```



### 线程有哪些方法

常见方法示例

```java
stop()											终止线程

lnterrupt()									线程中断

sleep()											睡眠

wait()											等待

notify()										唤醒

suspend()										挂起

join()											等待线程结束

yield()											谦让

synchronized								关键字 
```

### Java实现多线程有哪几种方式

​		有四种

​				1、继承Thread类，重写run方法

​				2、实现Runnable接口

​				3、实现Callable接口

​				4、线程池

​		下面我们来看看四种方式的代码实现吧：

​					继承Thread类，重写run方法，代码示例如下：

```java
/**
 * 继承Thread类，重写run方法
 */
public class ThreadDemo extends Thread {
    @Override
    public void run() {
        System.out.println("执行线程"+Thread.currentThread().getName());
    }
}

/**
 * 测试方法
 */
public class Test {
    public static void main(String[] args) throws InterruptedException {
        ThreadDemo threadDemo = new ThreadDemo();
        threadDemo.start();
    }
}
```

​					实现Runnable接口

```java
/**
 * 实现Runnable接口
 */
public class ThreadDemo implements Runnable {
    @Override
    public void run() {
        System.out.println("执行线程"+Thread.currentThread().getName());
    }
}

/**
 * 测试方法
 */
public class Test {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new ThreadDemo());
        thread.start();
    }
}
```

​					实现Callable接口

```java
import java.util.concurrent.Callable;

/**
 * 实现Runnable接口
 */
public class ThreadDemo implements Callable<String> {

    @Override
    public String call() throws Exception {
        return "执行线程"+Thread.currentThread().getName();
    }
}


import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * 测试方法
 */
public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ThreadDemo threadDemo = new ThreadDemo();
        FutureTask<String> task = new FutureTask<>(threadDemo);
        task.run();
        System.out.println(task.get());
    }
}
```

​					线程池

```java
import java.util.concurrent.Callable;

/**
 * 实现Runnable接口
 */
public class ThreadDemo implements Callable<String> {

    @Override
    public String call() throws Exception {
        return "执行线程"+Thread.currentThread().getName();
    }
}


import java.util.concurrent.*;

/**
 * 测试方法,注意：执行后并不会结束JVM因为main线程执行完了，依然有其他线程正在运行，线程池会创建核心线程进行执行任务
 * 我们可以通过修改核心线程数为0（把3改成0）然后
 */
public class Test {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ThreadDemo threadDemo = new ThreadDemo();
        ThreadPoolExecutor executor =
                new ThreadPoolExecutor(3,5,3, TimeUnit.SECONDS,new LinkedBlockingDeque<>(300),Executors.defaultThreadFactory());
        Future<String> submit = executor.submit(threadDemo);
        System.out.println(submit.get());
    }
}
```



### Callable和Future的了解

​		Callable接口代表一段可以调用并返回结果的代码 

​		Future接口表示异步任务，是还没有完成的任务给出的未来结果 

​		所以说Callable用于产生结果，Future用于获取结果。 

​		下面我们先来说下思路，Callable是可以获取线程返回的结果的，FutureTask的类实现了Future，我们通过FutureTask去拿到执行结果，如果我们的Callable里面处理太慢了影响到了调用线程的执行怎么办呢？不用担心因为他是异步的，并且只要不去get他的结果我们就不会阻塞住下面这几行代码就能体现Callable好处

下面是Callable实现

```java
public class TestCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        Thread.sleep(3000);
        System.out.println("未来任务执行完成");
        return 1;
    }
}
```

然后是任务调度

```java
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //创建FutureTask
        FutureTask<Integer> futureTask = new FutureTask<>(new TestCallable());
        //运行线程
        new Thread(futureTask).start();
        System.out.println("未来任务执行，先偷偷new个对象，打印出来");
        Object o = "偷偷的new出来的对象";
        System.out.println(o);
        //获取任务结果
        System.out.println(futureTask.get());
    }
```

我们可以看到我们启动了线程而这个线程是睡眠了的，我们在线程执行的时候偷偷new了个对象然后才去获取返回结果，那么在get的时候他就回去拿到值，我们一般都将get放在最后我们在get之前还能做其他的事情，这样就不会影响到别的执行了，执行结果如下

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024653839.png)

### 什么是CAS

​	CAS是英文单词Compare and Swap的缩写，翻译过来就是比较并替换 ，CAS是一种有名的无锁算法，那么它是如何实现无锁的呢，既然我们上面提到了CAS的翻译，那么肯定就是比较并且替换，在许多并发容器中有使用到，例如AtomicInteger，那么它是如何实现的呢？下面我们通过白话文来概述CAS的无锁机制

​	白话文：

​		CAS的无锁采用比较并替换，那么什么是比较并替换呢，我们假设一个数据的值为1，我们现在需要对他进行++的操作，那么我们拿到1，再拿到1+1，我们设置，在设置的时候我们会多传入一个参数，这个参数就是1，也就是我当前从主内存中获取到的内存，我们拿这个1去比较主内存中的数据，1=1，那么条件为true，这时我们就会去进行修改。将1修改为1+1，那么同时有另一个线程也从主内存中拿到了1，但是现在1已经被第一条线程修改为2了，那么另一条线程从主内存中获取到的1，他回去拿1进行比较，这个时候比较结果为false，修改失败，代码示例如下

​	我们可以看到如下代码执行时第一次修改成功第二次修改失败

```Java
    @Test
    public void testCas(){
        AtomicInteger atomicInteger = new AtomicInteger(1);

        boolean a = atomicInteger.compareAndSet(1, atomicInteger.get() + 1);
        boolean b = atomicInteger.compareAndSet(1, atomicInteger.get() + 1);

        System.out.println("第一次修改结果为：" + a + "，值为：" + atomicInteger.get());
        System.out.println("第二次修改结果为：" + b + "，值为：" + atomicInteger.get());
    }
```

​	那么是不是会有同学会疑问，那么这个值我们怎么才能保证当前取出来的是最新的呢，不用担心我们点进去看AtomicInteger的源码我们会发现，他的value是使用volatile关键字进行修饰的，也就是说他拿到的是主物理内存最新的数据，我们再来修改，这次我们的1采用atomicInteger进行获取，代码示例如下，喜欢测试的同学可以启用多条线程同时去修改atomicInteger测试

```
@Test
public void testCas(){
    AtomicInteger atomicInteger = new AtomicInteger(1);
    boolean a = atomicInteger.compareAndSet(1, atomicInteger.get() + 1);
    System.out.println("第一次修改结果为：" + a + "，值为：" + atomicInteger.get());
    boolean b = atomicInteger.compareAndSet(atomicInteger.get(), atomicInteger.get() + 1);
    System.out.println("第二次修改结果为：" + b + "，值为：" + atomicInteger.get());
}
```

### CAS以及UnSafe类

​		由于我们CAS在操作数据的时候，是直接修改主物理内存的地址的，而Java并没有提供直接修改主物理内存的方式，但是我们可以通过UnSafe的native 本地方法进行修改，Unsafe的大部分API都是native的方法，主要包括以下几类： 

​		Class相关。主要提供Class和它的静态字段的操作方法。

​		Object相关。主要提供Object和它的字段的操作方法。

​		Arrray相关。主要提供数组及其中元素的操作方法。

​		并发相关。主要提供低级别同步原语，如CAS、线程调度、volatile、内存屏障等。

​		Memory相关。提供了直接内存访问方法（绕过Java堆直接操作本地内存），可做到像C一样自由利用系统内存资源。

​		系统相关。主要返回某些低级别的内存信息，如地址大小、内存页大小。

​		我们在Jvm中提到过native的本地方法栈，封装了很多操作系统，以及内存和其他的拓展

### 自定义CAS并发容器

​		在其他的实现中都是别人封装好的Atomic原子类，那么我们现在有一个自己的实体类该如何封装呢？

​		其实非常简单，我们只需要使用一个引用就行了，下面以User类为示例

```
    @Test
    public void testCas(){
        AtomicReference<User> atomicReference = new AtomicReference<>();
        User a = new User();
        User b = new User();
        atomicReference.set(a);
        atomicReference.compareAndSet(a, b);
    }

```

### CAS的缺点

​	1、一直修改失败，导致时间过长，消耗CPU

​		在多线程的情况下，多个线程同时抢占，每次修改时其他线程总比一个或者多个线程先一步执行，如果长时间都没有修改成功对CPU的消耗比较大，会占用CPU空间

​	2、多变量原子操作

​		对多个共享变量进行操作时CAS就无法保证操作的原子性了，他只保证当前的比较对象的原子操作

​	3、ABA问题

​		在多线程环境中，使用 CAS，如果一个线程对变量修改 2 次，第 2 次修改后的值和第 1 次修改前的值相同，其他线程对此一无所知，这类现象称为 ABA 问题 ，下面这个例子可以帮助我们解决ABA问题

### CAS的ABA问题解决

​		我们使用AtomicStampedReference，通过原子引用比较，并且加上版本号来进行识别

```
    @Test
    public void testCas(){
        AtomicStampedReference<Integer> a = new AtomicStampedReference<>(100,0 );
        //第一次设置，设置为+1，同时版本号加一
        a.set(a.getReference()+1,a.getStamp()+1 );
        System.out.println("第一次设置值，设置成功,值为：" + a.getReference() + ",版本号为" + a.getStamp());
        //第二次设置，100 ！= 101，值比较失败，修改失败
        boolean one = a.compareAndSet(100, 102, a.getStamp(), a.getStamp()+1);
        System.out.println("第二次设置值，设置" + (one ? "成功":"失败") + ",值为：" + a.getReference() + ",版本号为" + a.getStamp());
        //第三次设置，101 == 101，版本号以及值都相等，修改成功，版本号+1
        boolean two = a.compareAndSet(101, 102, a.getStamp(), a.getStamp()+1);
        System.out.println("第三次设置值，设置" + (two ? "成功":"失败") + ",值为：" + a.getReference() + ",版本号为" + a.getStamp());
        System.out.println("最后值为：" + a.getReference() + ",版本号为：" + a.getStamp());
    }
```

### volitile关键字的作用

​		他是一个轻量级的同步机制，保证内存可见性（Memory Visibility）常用于保持内存可见性和防止指令重排序。 所有线程都能看到共享内存的最新状态，但是他不保证原子性。

```
public class MutableInteger {
    private int value;
    public int get(){
        return value;
    }
    public void set(int value){
        this.value = value;
    }
}

MutableInteger不是线程安全的，因为get和set方法都是在没有同步的情况下进行的。如果线程1调用了set方法，那么正在调用的get的线程2可能会看到更新后的value值，也可能看不到。

```

Java通过几种原子操作完成`工作内存`和`主内存`的交互 

1. lock：作用于主内存，把变量标识为线程独占状态。
2. unlock：作用于主内存，解除独占状态。
3. read：作用主内存，把一个变量的值从主内存传输到线程的工作内存。
4. load：作用于工作内存，把read操作传过来的变量值放入工作内存的变量副本中。
5. use：作用工作内存，把工作内存当中的一个变量值传给执行引擎。
6. assign：作用工作内存，把一个从执行引擎接收到的值赋值给工作内存的变量。
7. store：作用于工作内存的变量，把工作内存的一个变量的值传送到主内存中。
8. write：作用于主内存的变量，把store操作传来的变量的值放入主内存的变量中。

### volatile如何保持内存可见性

volatile的特殊规则就是：

- read、load、use动作必须**连续出现**。
- assign、store、write动作必须**连续出现**。

所以，使用volatile变量能够保证:

- 每次`读取前`必须先从主内存刷新最新的值。
- 每次`写入后`必须立即同步回主内存当中。

也就是说，**volatile关键字修饰的变量看到的随时是自己的最新值**。线程1中对变量v的最新修改，对线程2是可见的。 

volatile解析

https://www.cnblogs.com/monkeysayhi/p/7654460.html

### 不使用Volatile如何防止指令重排序

​			使用Unsafe魔法类中的内存屏障即可解决，对于内存屏障有3个

```
1、loadFence（读取屏障）
2、storeFence（写屏障）
3、fullFence（读写都带屏障）
```

​			那么我们只需要在设置属性的时候加上Unsafe对象的storeFence()方法即可。

​			如何获取Unsafe对象呢？

```java
   		Unsafe theUnsafe = null;
        try {
            theUnsafe = (Unsafe) Unsafe.class.getDeclaredField("theUnsafe").get(null);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        }
        theUnsafe.storeFence();
```





### synchronized关键字的用法，优缺点

​		可以用在代码块上，还有方法上面，synchronized 粒度有些大，在处理实际问题时存在诸多局限性。

### Java中阻塞线程和唤醒线程有哪些方式

​		答：一共有3种

​		分别是：

​				1、Object的wait()以及notify()方法

​				2、Condition的wait()以及notify()方法

​				3、LockSupport的park()以及unpark()方法

#### 1、Object对象的wait()以及notify()方法

​		使用Object对象wait()进行线程阻塞，使用Object中的notify唤醒线程。

```java
public class Test {
    public static void main(String[] args) {
        Object lock = new Object();
        synchronized (lock) {
            new Thread(() -> {
                Integer time = 3;
                synchronized (lock) {
                    while (time >= 1) {
                        System.out.println(Thread.currentThread().getName() + "还有" + time + "秒释放锁！");
                        for (int i = 0; i < time; i++) {
                            try {
                                Thread.sleep(1000);
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                        time -= 1;
                    }

                    lock.notify();
                }
            }, "线程一").start();

            try {
                lock.wait();
                System.out.println(Thread.currentThread().getName() + "线程执行完毕");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### 2、Condition类的await()以及signal()方法

​		使用JUC中的Condition的await()方法进行阻塞，使用signal()进行释放。

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Test {
    public static void main(String[] args) throws InterruptedException {
        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
        lock.lock();
        new Thread(() -> {
            lock.lock();
            Integer time = 3;
            while (time >= 1) {

                System.out.println(Thread.currentThread().getName() + "还有" + time + "秒释放锁！");
                for (int i = 0; i < time; i++) {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                time -= 1;
            }

            condition.signal();
            lock.unlock();
        }, "线程一").start();

        condition.await();
        lock.unlock();
        System.out.println(Thread.currentThread().getName() + "线程执行完毕");
    }
}
```

#### 3、LockSupport的park()以及unpark()方法

​		使用JUC中的LockSupport的park()方法阻塞，使用unpark()进行释放。

```java
import java.util.concurrent.locks.LockSupport;

public class Test {
    public static void main(String[] args) {
        Object lock = new Object();
        Thread thread = Thread.currentThread();
        new Thread(() -> {
            Integer time = 3;
            while (time >= 1) {
                System.out.println(Thread.currentThread().getName() + "还有" + time + "秒释放锁！");
                for (int i = 0; i < time; i++) {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                time -= 1;
            }
            LockSupport.unpark(thread);
        },"线程一").start();
        LockSupport.park(lock);
  			System.out.println(Thread.currentThread().getName() + "线程执行完毕");
    }
}
```

#### 三种阻塞唤醒线程方式的区别

```
1、Object的wait()以及notify()方法

		​	需要结合上synchronized关键字进行使用，并且需要先阻塞之后才能唤醒，可以唤醒其他所有阻塞线程。	
		
2、Condition的wait()以及notify()方法

		​	需要结合上Lock锁进行使用，并且也是需要先阻塞之后才能唤醒，可以唤醒其他所有阻塞线程。
		
3、LockSupport的park()以及unpark()方法

		​	不需要结合其他关键字或者锁使用，不需要先阻塞后唤醒，可以先唤醒，然后进行阻塞，如果先唤醒后阻塞则阻塞失效直接放行，不可以唤醒其他所有阻塞线程，并且他阻塞两次唤醒两次最终还是会阻塞，只能阻塞一次然后进行唤醒一次。
		
```



### sleep和wait的区别

​		sleep是睡眠，他指定了一个时间，他会时刻的监视这个时间如果一旦到达就会继续运行，但是wait的睡眠他会让进入到一个类似等待池的状态，在这个状态中他是真正的睡眠，如果不去唤醒他会一直进入到休眠，这个时候就需要唤醒了，我们可以使用notify（在只有两个线程时）他会被其他线程唤醒，但是如果多个线程都在睡眠，这个情况下使用notify就不一定有效了，那么我们可以使用notifyall。

### notify和notifyall的区别

​		notify是唤醒一个线程，这个线程并不能我们指定的去唤醒，但是他会让正在休眠的线程中的某一个线程唤醒，而notifyall则是让所有的睡眠的线程进行唤醒。

# 线程池详解

### 常见的线程池有哪几种

​	**1. newSingleThreadExecutor** 

​		创建一个单线程的线程池。这个线程池仅仅有一个线程在工作，也就是相当于单线程串行运行全部任务。假设这个唯一的线程由于异常结束，那么会有一个新的线程来替代它。此线程池保证全部任务的运行顺序依照任务的提交顺序运行。 

​	**2. newFixedThreadPool** 

​		创建固定大小的线程池。每次提交一个任务就创建一个线程。直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变。假设某个线程由于运行异常而结束，那么线程池会补充一个新线程。 

​	**3. newCachedThreadPool** 

​		创建一个可缓存的线程池。假设线程池的大小超过了处理任务所须要的线程.那么就会回收部分空暇（60秒不运行任务）的线程，当任务数添加时。此线程池又可以智能的加入新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小全然依赖于操作系统（或者说JVM）可以创建的最大线程大小。

​	**4. newScheduledThreadPool** 

​		创建一个大小无限的线程池。此线程池支持定时以及周期性运行任务的需求。

### 线程池的接口和依赖的关系

​	Executor				父类接口

​	ExecutorService			继承Executor

​	AbstractExecutorService	实现ExecutorService

​	ThreadPoolExecutor 		继承AbstractExecutorService

### 线程池参数有哪些

int corePoolSize							//核心线程数,允许同时执行任务的最大线程数

int maximumPoolSize						// 最大线程数，允许同时处理任务的最大线程数

long keepAliveTime						// 超出核心线程数的空闲线程的最大存活时间

TimeUnit unit							//空闲线程存活时间单位

BlockingQueue<Runnable> workQueue		// 阻塞任务队列，存储待执行的任务

ThreadFactory threadFactory				// 线程工厂，用于创建线程，可指定线程命名规则

RejectedExecutionHandler handler			// 饱和策略(拒绝策略)，当线程池阻塞队列已满时对新任务的处理

​	ThreadPoolExecutor.AbortPolicy;		//丢弃任务并抛出RejectedExecutionException异常。 			

​	ThreadPoolExecutor.DiscardPolicy;		//也是丢弃任务，但是不抛出异常。 

​	ThreadPoolExecutor.DiscardOldestPolicy;//丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）

​	ThreadPoolExecutor.CallerRunsPolicy;	//由调用线程处理该任务

### 线程小故事

先讲讲核心线程数和最大线程数：

​	那么我们要知道线程池是有最大线程数和核心线程数的，那么什么是最大线程数和核心线程数呢？我们来打个比方吧，我们好比一个网吧，一共有20台机器，那么最大线程数就是20台机器，如果我们把核心线程数设置为5个，那么这五台机器我们一直把它开着，别人需要上机发现机器开着坐上来就能输入账号上机，如果这5台机器坐满了，其他的人来了那么他就去其他15台机器开机上机，也就是说核心线程数随时都能提供服务，他一直处于就绪状态

​	表示我们平时最少都要有5个线程就绪准备干活，如果5个线程忙不过来我们就创建新的线程进行处理，但是最大只能有20个，这还是包括了核心的5个



然后我们再来讲一讲超时存活时间和单位：

​	我们现在又好比一个网吧，现在20台机器，5台核心线程，还有15台，这15台有10个人走了，但是这10台电脑没有关电源，那么我们需要在之后什么时间关，例如1，那么1就是存活时间，单位为分钟，那么如果走了一分钟还是没人来使用，那么我们就把电源给关闭了，但是如果下次有人来用还是在只是他需要去开启电源

​	核心线程要一直就绪状态，最大线程如果空闲有多的在什么时候我们给他关闭掉



然后再讲讲阻塞队列的作用：

​	我们来打个比方吧，我们好比一个网吧，一共有20台机器，这20台机器就是最大的线程数，这个网吧就是一个线程池，现在来了22个人，那么就有20个人上机了，还剩下两个人，怎么办呢，那么他们就会有一个休闲的沙发坐，这个沙发我们就可以认为是一个阻塞队列，我们不能把客人赶出去， 这个阻塞队列就是让他休息的地方的，并且这个沙发是有长度的长度越长，它的能休闲等待的人就越多

​	如果现在来了200个线程，那么就会开启最大线程的处理20个，剩下的180个我们全部把他给放在阻塞队列中等待执行



那么我们再来说一下拒绝策略吧：

​	我们来打个比方吧，我们好比一个网吧，一共有20台机器，这20台机器就是最大的线程数,现在还有一个沙发能坐10个人，我们现在来了34个人，坐满了20台机器，沙发也坐了10个人，还剩下3个人，这三个人的处理方式有很多种，

​	ThreadPoolExecutor.AbortPolicy;		//丢弃任务并抛出RejectedExecutionException异常。 

​		我们直接把人撵出去并且骂他			

​	ThreadPoolExecutor.DiscardPolicy;		//也是丢弃任务，但是不抛出异常。 

​		我们好好的和他说满了，沙发也满了说坐不下了

​	ThreadPoolExecutor.DiscardOldestPolicy;//丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）

​		我们把最先来的要下机的说一下，要下机了，然后让后面的人上机

​	ThreadPoolExecutor.CallerRunsPolicy;	//由调用线程处理该任务

​		这里就是比如网关叫别人来上网，现在都满了，就把网管的电脑给这个人玩

​	这几个策略也就是4个如解释所说的功能

### 阻塞队列

​	我们来讲一下阻塞队列，阻塞队列，阻塞队列其实也是基于Collection接口子接口，因为他基于Queue队列，而队列又基于Collection集合，所以阻塞队列也属于集合

​	那么我们先来讲讲使用吧，他其实就是在put的时候判断当前的数量和数组或者队列的长度，如果数量和队列一样则await停止

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024676619.png)

下面我们先来讲讲代码的思路，首先我们会向阻塞队列中put元素，我们阻塞队列长度为200，同时我们启动202个线程去put元素，那么这个时候肯定会有两个多出来的被阻塞，然后我们再main线程中睡眠3秒然后从队列取出一个，这时会释放一个线程，但是还是有一个阻塞住的，我们过3秒再取出一个至此取出完成，长度200，打印长度结束，下面是示例代码



我们这里采用的ArrayBlockingQueue，还有链表的LinkedBlockingQueue，不过推荐使用链表的因为链表在写入比较快

```
    public static volatile BlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<>(200);
    //链表方式new LinkedBlockingQueue<>(200);
    public static volatile ReentrantLock reentrantLock = new ReentrantLock();
    public static void main(String[] args) throws InterruptedException {
        //创建一个200长度的阻塞队列
        for (int i = 0; i < 202; i++) {
            //创建202个线程去进行写入操作
            new Thread(() -> {
                try {
                    reentrantLock.lock();
                    System.out.println(Thread.currentThread().getName() + "号开始阻塞");
                    //在put到200时，一定会阻塞
                    blockingQueue.put(Integer.valueOf(Thread.currentThread().getName()));
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }finally {
                    reentrantLock.unlock();
                    System.out.println(Thread.currentThread().getName() + "号解除阻塞");
                }
            },String.valueOf(i+1)).start();
        }
        //睡眠3秒，从队列取出一个对象，还是不释放阻塞队列
        Thread.sleep(3000);
        System.out.println("------------------------------------");
        blockingQueue.poll();
        //睡眠3秒，从队列再取出一个对象，释放阻塞队列
        Thread.sleep(3000);
        System.out.println("------------------------------------");
        blockingQueue.poll();
        //防止打印太快，输出数据不一致
        Thread.sleep(100);
        //打印阻塞队列最终长度
        System.out.println("阻塞队列释放完成，当前长度：" + blockingQueue.size());
    }
```

### 阻塞队列有哪些

​			ArrayBlockingQueue				//有界		基于数组实现的阻塞队列

​			LinkedBlockingQueue 			//假.无界	基于链表实现的阻塞队列

​			PriorityBlockingQueue			//无界       并且支持优先级排序的阻塞队列

​			DelayQueue							  //无界       使用优先级队列实现的无界阻塞队列

​			SynchronousQueue				//有界		只有一个长度的阻塞队列

​		    LinkedBlockingDeque             //假.无界	类似于LinkedBlockingQueue，但是他是双向阻塞队列

​			LinkedTransferQueue			 //无界          由链表结构组成的无界阻塞独立额

### 使用无界阻塞队列会出现什么问题？

​			虽然LinkedBlockingQueue是有界的但是我们直接将磨人的看成无界，还有其他的无界的阻塞队列例如

​			无界阻塞队列指的是什么呢？也就是使用了LinkedBlockingQueue并且没有初始化参数的线程池，那么他就会自动创建一个阻塞队列的长度为int的最大值的阻塞链表队列，我们来看下LinkedBlockingQueue的构造方法吧

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024705885.png)

这个值是2147483647，大约在21亿左右，想象一下现在几千万个线程进来了，瞬间就把jvm给撑爆了，这是非常危险的，所以我们在使用的时候尽量不要使用它自带的线程池，我们自己根据的参数去自定义线程池会更好



### 如何自定义一个线程池

​	首先是我们要知道线程池的核心是什么其实就是从ThreadPoolExecutor中创建来的，那么我们来看一下ThreadPoolExecutor的使用，分别介绍了他的7个参数以及用法，首先

5												是核心线程数

10											是最大线程数（最大线程数中包含核心线程数）

3L											表示超时时间3，单位下面指定

TimeUnit.MICROSECONDS						表示超时时间单位						

​	TimeUnit.DAYS          			 //天  
​	TimeUnit.HOURS        			 //小时  
​	TimeUnit.MINUTES      		 //分钟  
​	TimeUnit.SECONDS      		 //秒  
​	TimeUnit.MILLISECONDS  		 //毫秒 
​	TimeUnit.NANOSECONDS   	 //毫微秒

​	TimeUnit.MICROSECONDS  	//微秒

 Executors.defaultThreadFactory()				使用Executors默认的线程工厂

new LinkedBlockingQueue<>(30)				阻塞队列长度为30，一个项目的最大并发数就是最大线程数+阻塞队列数

​			常用的三个阻塞队列（一共）

​			SynchronousQueue			单个阻塞队列

​			ArrayBlockingQueue			由数组构建的有界的阻塞队列

​			LinkedBlockingQueue			由链表构建的无界的阻塞队列（默认为Integer的max值也就是21亿，不推荐直接使用最大值）

​	拒绝策略

​			new ThreadPoolExecutor.AbortPolicy();	 	如果超过了阻塞队列+最大线程池的数量的并发抛出异常 	

​			new ThreadPoolExecutor.DiscardPolicy();		如果超过了阻塞队列+最大线程池的数量的并发直接丢弃

​			new ThreadPoolExecutor.DiscardOldestPolicy();如果超过了阻塞队列+最大线程池的数量的并发丢弃最前面的尝试执行下一个线程，也就是超过的有可能被执行一次

​			new ThreadPoolExecutor.CallerRunsPolicy();	如果超过了阻塞队列+最大线程池的数量的并发如果自己处理不了那么交给调用的线程执行，也就是main线程调用线程池，但是超过了，那么线程池处理不了交给main线程进行执行

```
        Executor executor = new ThreadPoolExecutor(
                5,
                10,
                3L,
                TimeUnit.MICROSECONDS,
                new LinkedBlockingQueue<>(30),
                Executors.defaultThreadFactory(),
                new ThreadPoolExecutor.CallerRunsPolicy());
```

​	这个就是自定线程池的过程，那么我们来介绍如何合理的设置线程池参数

### 合理线程池参数定制

​	尽量还是使用第一种减少上下文切换

​	CPU密集型

​		由于要保证线程的计算速度也就是高利用CPU的性能,减少CPU的上下文切换导致的损耗

​		计算模式

​			（注：单核CPU告辞）

​			CPU核数+1

​	IO密集型

​		分两种

​			CPU * 2		(推荐第二种)

​			CPU / 1  - 阻塞系数	阻塞系数为0.8-0.9

# 锁相关

### Lock接口有哪些实现类，使用场景是什么

​		Lock有三个实现类

​			ReentrantLock （可重入锁）

​			ReentrantReadWriteLock.ReadLock（读锁）

​			ReentrantReadWriteLock.WriteLock（写锁）

### 可重入锁的用处及实现原理

#### 什么是可重入锁

​	可重入锁ReentrantLock，他是一个可重入锁，他指的是同一线程外层获得锁之后，内层递归函数仍然能获取该锁的代码，在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，也就是说，线程可以进入任何一个它已经拥有锁的锁同步者的代码块

​	注：（synchronized也是一个可重入锁）

​	注：（一个线程，线程调用A方法A方法中调用到B方法）我们可以这样理解，两个方法都用到了锁，A方法调用B方法，他们使用的是同一个锁，那么我们使用可重入锁，A拿到锁执行到B进入B方法，那么这个时候他就回去自动获取这个锁，通常这个锁是会等他放开了我们才能拿到，现在我们可以直接自动拿到并执行，然后执行完毕B方法执行完了，这个栈就开始出栈了，他会返回到A然后A执行完毕，它的作用是为了防止死锁

​		代码示例：

​			首先我们采用synchronized来进行示范可重入锁，重入锁又分为锁代码块和锁方法此处演示锁代码块

```java
public class Test {
    public static void main(String[] args) {
        Test test = new Test();
        // 多重锁，同一线程内锁嵌套，并且锁同一个对象
        new Thread(() -> {
            synchronized (test){
                System.out.println("外层锁");
                synchronized (test){
                    System.out.println("中层锁");
                    synchronized (test){
                        System.out.println("内层锁");
                    }
                }
            }
        }).start();
    }
}
```

​			然后我们再来使用ReentrantLock来进行可重入锁的锁方法

```java
import java.util.concurrent.locks.ReentrantLock;

public class Test {
    ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        Test test = new Test();
      	// 调用lock1，lock1调用2，2调用3
        test.lock1();
    }

    public void lock1(){
        lock.lock();
        System.out.println("外层锁");
        lock2();
        lock.unlock();
    }

    public void lock2(){
        lock.lock();
        System.out.println("中层锁");
        lock3();
        lock.unlock();
    }

    public void lock3(){
        lock.lock();
        System.out.println("内层锁");
        lock.unlock();
    }
}

```

​		同时他实现了公平锁和非公平锁，可以通过他的构造方法来进行指定

```
        ReentrantLock nonfairSync = new ReentrantLock(false);
        ReentrantLock fairSync = new ReentrantLock(true);
```

​		具体体现在他的构造方法中，它默认使用的非公平锁

​		![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024720218.png)

​	并且默认的构造方法是非公平锁

​	![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024731896.png)

#### 什么是公平锁

​	公平锁表示线程公平，按序执行，并且保证原子性

```java
import java.util.concurrent.locks.ReentrantLock;

public class MyFairLock {
    /**
     *     true 表示 ReentrantLock 的公平锁
     */
    private  ReentrantLock lock = new ReentrantLock(true);

    public   void testFail(){
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName() +"获得了锁");
        }finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {
        MyFairLock fairLock = new MyFairLock();
        Runnable runnable = () -> {
            System.out.println(Thread.currentThread().getName()+"启动");
            fairLock.testFail();
        };
        Thread[] threadArray = new Thread[10];
        for (int i=0; i<10; i++) {
            threadArray[i] = new Thread(runnable);
        }
        for (int i=0; i<10; i++) {
            threadArray[i].start();
        }
    }
}
```

输出结果

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024765098.png)

​		这样的话那么他就是一个公平锁我们可以

#### 什么是非公平锁

非公平锁不保证公平性，不会刻意去控制线程，但是性能高

```java
public class MyNonfairLock {
    /**
     *     false 表示 ReentrantLock 的非公平锁
     */
    private  ReentrantLock lock = new ReentrantLock(false);

    public  void testFail(){
        try {
            lock.lock();
            System.out.println(Thread.currentThread().getName() +"获得了锁");
        }finally {
            lock.unlock();
        }
    }
    public static void main(String[] args) {
        MyNonfairLock nonfairLock = new MyNonfairLock();
        Runnable runnable = () -> {
            System.out.println(Thread.currentThread().getName()+"启动");
            nonfairLock.testFail();
        };
        Thread[] threadArray = new Thread[10];
        for (int i=0; i<10; i++) {
            threadArray[i] = new Thread(runnable);
        }
        for (int i=0; i<10; i++) {
            threadArray[i].start();
        }
    }
}
```

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024787356.png)

#### 使用多层可重入锁，不释放有什么问题？

​		如果在一段代码中使用了多层lock上锁，那么会出现什么问题呢？

​		答：如果使用了多层lock，他既不会编译失败也不会运行失败，但是如果我们上了3层锁只解开了两层那么就会导致其他线程获取锁僵死。

​		解：可重入锁（递归锁）同一线程可重入，通过记录锁数量执行，如果上锁与解锁不一致，当前线程无影响，其他线程获取锁时则导致获取失败僵死。

​		代码示例如下：

```java
import java.util.concurrent.locks.ReentrantLock;

public class Test {
    static ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        // 线程一三次上锁，两次解锁，代码无影响
        new Thread(() -> {
            // 三次上锁
            lock.lock();
            lock.lock();
            lock.lock();
            System.out.println(Thread.currentThread().getName()+"上锁");
            // 两次解锁
            lock.unlock();
            lock.unlock();
            System.out.println(Thread.currentThread().getName()+"解锁");
        },"线程一").start();
        // 线程二则获取锁然后解锁
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName()+"尝试获取锁,线程僵死则获取锁失败");
            lock.lock();
            System.out.println(Thread.currentThread().getName()+"上锁");
            lock.unlock();
            System.out.println(Thread.currentThread().getName()+"解锁");
        },"线程二").start();
    }
}
```

​		执行结果为

```
线程一上锁
线程一解锁
线程二尝试获取锁,线程僵死则获取锁失败
```

​		表示我们线程二没有获取到锁对象

​		注意事项：

​				使用多层可重入锁（递归锁）切记一定要释放锁，并且尽量使用try catch finally代码块，防止异常导致获取不到锁

```java
import java.util.concurrent.locks.ReentrantLock;
public class Test {
    static ReentrantLock lock = new ReentrantLock();
    public static void main(String[] args) {
        try {
            lock.lock();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}
```



### 自旋锁

​	这里就和前面的CAS有一点类似了，我们知道CAS他会去不停的请求比较并且修改，那么如果在多个线程的情况中，会产生一个问题，如果我一直修改不到，比如100个线程修改，第一个修改完了，其他线程去修改，现在有一个非常倒霉的线程，他一直修改不了，其他99条线程在一直修改，那么他就会一直循环，这个状态我们叫做自旋，当其他的99条修改完成之后，他才拿到最新的数据并且修改完成

### 读写锁

​		读写锁分读锁和写锁，读锁又被成为共享锁，写锁被称为独占锁，意思就是读锁是共享的我们都能读，写锁被称为独占锁，也就是写的时候我们只能一个人去进行写操作。如果我们直接使用synchronized那就会锁住整个块，不论你是读取还是写入都会加锁，那么这样大大影响了效率，因为我们在写入的时候需要保证安全，而在读取数据的时候我们一般来说并不需要加锁所以就产生了读写锁

​		下面为读写锁的使用

```java
        //创建读写锁对象
        ReentrantReadWriteLock reentrantReadWriteLock = new ReentrantReadWriteLock();
        //使用写锁
        try {
            reentrantReadWriteLock.writeLock().lock();
            //逻辑业务代码
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            reentrantReadWriteLock.writeLock().unlock();
        }

        //使用读锁
        try {
            reentrantReadWriteLock.readLock().lock();
            //逻辑业务代码
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            reentrantReadWriteLock.readLock().unlock();
        }
```

### 线程的状态都有哪些

​		创建   

​		准备

​		运行或者阻塞

​		死亡

​		一共有5个状态

# JUC工具类

## JUC锁

### **AbstractQueuedSynchronizer**（AQS）（JUC并发包实现的基类）

​		AbstractQueuedSynchronizer（AQS），简称抽象的一个队列同步器，首先我们需要理解他是一个什么东西？

​		队列同步器，我们可以知道他是一个使用了队列的同步器，同时他也是一个抽象的类，也就是说他给我们定义了一个规范，如何去实现这个抽闲队列同步器。

​		那么首先我们来看一看JDK源码中对AQS的一个解释，翻译后解释如下：

```
			提供一个框架来实现依赖于先进先出（FIFO）等待队列的阻塞锁和相关的同步器（信号灯，事件等）。
			此类旨在为大多数依赖于此的同步器提供有用的基础单个原子{@code int}原子值表示状态。
			子类必须定义更改此状态的受保护方法，并定义状态对于获取或释放此对象而言意味着什么。
			鉴于这些，此类中的其他方法将执行所有排队和阻塞机制。
			子类可以维护其他状态字段，但是仅跟踪关于同步的使用方法
					{@link #getState}
					{@link＃setState}和
					{@link #compareAndSetState}
			操作的原子更新的{@code int}值。
-----------------------------------------------------------------------
			子类应定义为用于实现其封闭类的同步属性的非公共内部帮助器类。
			类{@code AbstractQueuedSynchronizer}不实现任何同步接口。
			相反，它定义了诸如{@link #acquireInterruptible}之类的方法，可以通过具体的锁和相关的同步器适当地调用这些方法以实现其公共方法。
-----------------------------------------------------------------------
```

​		AbstractQueuedSynchronizer的使用依靠继承来完成，子类通过继承自AQS并实现所需的方法来管理同步状态。提供了一个基于FIFO队列，可以用于构建锁或者其他同步装置的基础框架,AQS可以同时实现排它锁和共享锁模式使用方法是继承，子类通过继承并通过实现它的方法管理其状态｛acquire 和release｝的方法操纵状态

## JUC工具类

### CountDownLatch

​		下面以CountDownLatch为例子，做一个杀提莫游戏，下面是没有使用CountDownLatch的代码

```java
    public static void main(String[] args) {
        //循环10个线程，每一个线程都杀一个提莫
        for (int i = 0; i < 10; i++) {
            new Thread( () -> {
                System.out.println("正在杀第"+Thread.currentThread().getName()+"个提莫");
            },String.valueOf(i+1)).start();
        }
        System.out.println("已经杀完提莫");
    }
```

​	然后我们就会看到，他并没有执行完线程，就打印出了杀提莫（每次执行情况不一致）

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024811492.png)

然后我们再来看看使用了CountDownLatch的代码

```java
    public static void main(String[] args) {
        //创建CountDownLatch对象，并且初始化10个单位
        CountDownLatch countDownLatch = new CountDownLatch(10);
        //循环10个线程，每一个线程都杀一个提莫
        for (int i = 0; i < 10; i++) {
            new Thread( () -> {
                System.out.println("正在杀第"+Thread.currentThread().getName()+"个提莫");
                //杀完后countDownLatch计数countDown一下
                countDownLatch.countDown();
            },String.valueOf(i+1)).start();
        }
        try {
            //线程等待，等待计数完成释放线程
            countDownLatch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("已经杀完提莫");
    }
```

然后我们可以看到，他已经执行了，并且成功的在杀完之后才去进行提示，无论我们执行多少次他都是在杀完了之后才执行的

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024829036.png)



### CyclicBarrier

​		CyclicBarrier简介，CyclicBarrier是一个同步辅助类，它允许一组线程相互等待直到所有线程都到达一个公共的屏障点 在程序中有固定数量的线程，这些线程有时候必须等待彼此，这种情况下，使用CyclicBarrier很有帮助，这个屏障之所以用循环修饰，是因为在所有的线程释放彼此之后，这个屏障是可以重新使用的，我们知道CountDownLatch是做计数减少的，而CyclicBarrier是增量到一定数释放的，那么我们来看一下收集龙珠的例子吧

​		下面是一个没有使用CyclicBarrier收集龙珠例子

```java
    public static void main(String[] args) {
        for (int i = 0; i < 7; i++) {
            new Thread(() -> {
                System.out.println("收集第"+ Thread.currentThread().getName()+"颗龙珠");
            },String.valueOf(i+1)).start();
        }
        System.out.println("集齐7颗龙珠");
    }
```

​		我们可以看到打印的结果，还没有集齐7颗龙珠就打印了

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024847502.png)

​		我们再来看一下使用了CyclicBarrier的例子

```java
    public static void main(String[] args) {
        //创建CyclicBarrier，收集到7颗之后执行的线程，也可以不执行
        CyclicBarrier cyclicBarrier = new CyclicBarrier(7,() -> {
            System.out.println("集齐7颗龙珠");
        });
        //创建线程收集7颗龙珠
        for (int i = 0; i < 7; i++) {
            new Thread(() -> {
                System.out.println("收集第"+ Thread.currentThread().getName()+"颗龙珠");
                try {
                    //cyclicBarrier每次await增量+1
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }
                System.out.println("退还第"+ Thread.currentThread().getName()+"颗龙珠");
            },String.valueOf(i+1)).start();
        }
    }
```

​		我们可以看到使用了CyclicBarrier的例子，先是收集了7颗龙珠，然后集齐，然后在await之后然后退还

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024918023.png)

### Semaphore

​		Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。 从字面上很难理解Semaphore所表达的含义，只能把它比作是控制流量的红绿灯，比如XX马路要限制流量，只允许同时有一百辆车在这条路上行使，其他的都必须在路口等待，所以前一百辆车会看到绿灯，可以开进这条马路，后面的车会看到红灯，不能驶入XX马路，但是如果前一百辆中有五辆车已经离开了XX马路，那么后面就允许有5辆车驶入马路，这个例子里说的车就是线程，驶入马路就表示线程在执行，离开马路就表示线程执行完成，看见红灯就表示线程被阻塞，不能执行。 

​		我们可以把他当成一个池子，只能有30个人游泳，如果来了40个人，那么进去30个，剩下的10个等着，游泳池的人走一个，然后后面的人进一个

​		应用场景：

​			Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。 

​		那么我们来看一下没有使用Semaphore的时候是怎样的的吧

```java
    public static void main(String[] args) {
        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                    System.out.println("第" + Thread.currentThread().getName() + "辆车进来");
                    System.out.println("第" + Thread.currentThread().getName() + "辆车出去");
            },String.valueOf(i+1)).start();
        }
    }
```

​		我们可以看到执行的结果，一大堆线程不按顺序，并且全部都跑过来了

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568024936522.png)

​		那么我们现在想最多只能有3个线程一起执行，超过3个的等待，那么我们如何实现呢我们可以使用Semaphore

```java
    public static void main(String[] args) {
        //创建Semaphore并且制定长度为3
        Semaphore semaphore = new Semaphore(3);
        for (int i = 0; i < 6; i++) {
            new Thread(() -> {
                try {
                    //信号灯使用+1
                    semaphore.acquire();
                    //开始使用
                    System.out.println("第" + Thread.currentThread().getName() + "辆车进来");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    try {
                        //随机Id睡眠
                        Thread.sleep(Thread.currentThread().getId() * 1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println("第" + Thread.currentThread().getName() + "辆车出去");
                    //使用完成释放信号灯
                    semaphore.release();
                }
            },String.valueOf(i+1)).start();
        }
    }
```

然后我们看执行结果，由于我睡眠了所以效果更佳直观（可能时间会有点久）

![](img\Semaphore——2.png)

我们可以看到第一次进来了3辆车，然后出去一辆进来一辆，但是每次最多只有3辆车在停车场



### CyclicBarrier和CountDownLatch的区别是什么？

​		CountDownLatch，使用的是减计数的方式，计算为0时释放所有等待的线程，计数为0时无法重置，调用countDown方法进行计数减一，调用await方法进行阻塞，对计数没有任何的影响

​		CyclicBarrier，使用的是加计数的方式，计数达到指定值时释放，计数重置为0重新开始，调用await时+1，如果加1不等于构造方法的值则线程阻塞，他是可重复利用的，它可以通过它的reset方法来重置，而CountDownLatch使用了就没了

### 

# Java的并发容器有哪些？哪些是同步容器哪些是并发容器

