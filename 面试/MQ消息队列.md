

# 为什么要引入消息队列，引入理由是什么

​		主要原因是由于在高并发环境下，由于来不及同步处理，请求往往会发生堵塞，比如说，大量的insert，update之类的请求同时到达数据库，直接导致无数的行锁表锁，甚至最后请求会堆积过多，从而触发too many connections错误，以及对于一部分不是强一致性的操作，例如发送短信，发送邮件或者其他的可以异步执行，以及保持最终一致的数据我们都可以采用消息队列进行处理。

​		主要有如下用处：

- ​				应用解耦（通用功能）
- ​                异步操作
- ​                流量消峰（高访问量使用队列排队处理）
- ​                消息通知（短信，邮件等）

# 项目中你们是怎么使用消息队列的

​		主要用于消息数据处理，例如大量的爬虫数据，分析过滤入库操作，可以采用MQ方式进行消费，以及发送短信操作，发送邮件，以及生成图片，还有分布式消息通知，例如多节点发布订阅消息，进行处理，以及其他各种系统可能会出现重复的功能解耦。

# 主流消息队列都有哪些？

​		ActiveMQ

```properties
		# Apache ActiveMQ是Apache软件基金会所研发的开放源代码消息中间件；由于ActiveMQ是一个纯Java程序，因此只需要操作系统支持Java虚拟机，ActiveMQ便可执行。
		
		特点: 
				单机吞吐量: 万级
				  消息延迟: 毫秒级
		总结: 老牌MQ，采用纯JAVA编写，性能一般，中规中矩
```

​		Kafka

```properties
		# Kafka是由Apache软件基金会开发的一个开源流处理平台，由Scala和Java编写。Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据。 
		
		特点: 
				单机吞吐量: 十万级
				  消息延迟: 毫秒级
		总结: 吞吐量高，适合大量数据处理，但是可能会丢失消息，以及重复消费
```

​		RabbitMQ

```properties
		# RabbitMQ是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而集群和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。
		
		特点: 
				单机吞吐量: 万级
				  消息延迟: 微秒级
		总结: 性能高，延迟低，但是采用Erlang编写，不方便集群拓展，功能强大，但吞吐量一般
```

​		RocketMQ

```properties
		# RocketMQ的最佳实践，包括生产者、消费者、Broker以及NameServer的最佳实践，客户端的配置方式以及JVM和linux的最佳参数配置。采用Java开发。
		
		特点: 
				单机吞吐量: 数万级
				  消息延迟: 毫秒级
		总结: 延迟一般，吞吐量较高，并且对数据的一致性保持较高，功能强大，是目前性能较高的MQ
```

# Kafka

## 消息丢失如何解决

​		我们在发送消息的时候可能会出现消息丢失的情况，例如我们发送消息给某一个Topic分区，这个时候发送到了Leader上，但是Leader没有来得及同步数据给副本，自己就挂掉了，这个时候我们的消息就会丢失，由于副本升级为Leader但是他并没有从原来的Leader同步到数据，所以导致了数据丢失。

​		针对与这种情况，Kafka的生产者给我们提供了配置，我们可以通过配置**acks**属性来设置，对应的防止消息丢失的情况。

​		**acks**设置一共有三个属性

```properties
		#acks = 0 
       如果设置为零，则生产者将不等待来自的任何确认完全是服务器。记录将立即添加到套接字缓冲区中并视为已发送。无法保证。表示服务器在这种情况下已收到记录，也就是我们的生产者像Broker代理发送消息，我们不保证Broker收到了消息，如果我们生产者发送消息到Socket缓冲区，我们就认为他发送成功了，会导致消息丢失，retries配置将不会生效（因为客户端通常不会知道任何故障）。为每个记录提供的偏移量将是始终设置为-1。
		# acks = 1 (可能消息丢失)
        这将意味着领导者会将记录写入其本地日志，但会做出响应而无需等待所有关注者的完全确认。在这种情况下，领导者应在之后立即失败确认记录，但是在关注者复制该记录之前该记录将丢失，我们向Broker发送消息，至少写入Leader，然后Leader将数据同步到1个副本集中，我们就认为他已经是属于发送成功了。
		# acks = all（消息不丢失）
        这意味着领导者将等待完整的同步副本到确认记录。这保证只要至少一个同步副本，记录也不会丢失仍然有效。这是最强大的保证。它等于acks=-1的设置，表示我们发送消息到Broker，然后分区Leader写入，写入完成后必须将数据再同步给所有的副本，同步完成后才数据发送成功。
    
    # 发送失败会导致生产者循环发送消息，直到发送成功为止，可以通过其他配置修改
```

## 消息重复如何解决

​		同样是在生产者，为了防止我们发送消息的时候由于网络抖动，或者其他的的原因，导致处理消息丢失或者其他情况时所引起的消息生产发送重复，引起的数据混乱，那么针对这种情况我们可以通过开启Kafka的幂等性来防止消息重复，通过属性**enable.idempotence**

```properties
		# 将幂等性开启，幂等性会在发送消息的时候附带上一个序列ID，如果出现了消息重试等操作，根据这个序列ID我们可以防止消息的重复
```

