# **缓存相关**

## redis和memcached的区别

​		相对于 Memcached，来说如果他断电了数

​			据也就没有了，不能像Redis一样支持数据的持久化，在这一点上Redis做的比他好，并且它包含了

​			Memcached的几乎所有的功能并且比他更加强大，作为Java来说Redis是一个不错的缓存数据库，

​			这只是Redis的一部分功能，还有更多的强大的功能，并且Memcached只支持json格式的字符串，	

​			但是Redis支持很多种数据类型，所以在现在的市场上Memcached已经逐渐被Redis取代了

## redis支持哪些数据结构

​		五种数据类型：

​						字符串（String）

​						哈希（hash）

​						字符串列表（list）

​						字符串集合（set）

​						有序字符串集合（zset       sorted set）

​		但是在Redis5.0中发布了新的数据类型

​			Stream data type 

## redis是单线程的么，所有的工作都是单线程么

​		Redis是单线程的，redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。 所有的工作并不是单线程的，而是使用I/O的多路复用，



​		Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的 



​		那么什么是多路I/O的复用呢？		

​		多路指的是多个TCP连接，复用指一个或者多个线程进行处理，在Redis中是单线程的，简单的理解就是多个TCP连接进行数据写入的请求，通过一个单线程进行多路的IO写入，这个就是多路IO复用，但是I/O的多路复用也是有很多种模型的，常见的有、	select	 、  poll  	、epoll	

​		而在Redis当中使用的epoll

## redis如何存储一个String的

​		通过他的Key  Value的键值对进行存储，

## 一个key值如何在redis集群中找到存储在哪里

​		一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每
个键都属于这 16384 个插槽的其中一个， 集群使用公式 CRC16(key)
% 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计
算键 key 的 CRC16 校验和 。
• 集群中的每个节点负责处理一部分插槽。 举个例子， 如果一个集群
可以有主节点， 其中：
节点 A 负责处理 0 号至 5500 号插槽。
节点 B 负责处理 5501 号至 11000 号插槽。
节点 C 负责处理 11001 号至 16383 号插槽。

​		那么redis如果有3个节点，就会根据他的key进行计算key的CRC16的值然后来对16384 进行取模的操作

​		也就是（Key 计算后的CRC16    %     16384），然后再计算取模后的值在哪一个节点中，例如取模后是3000，那么他就会找到3000的这个槽，3000的这个槽是在A节点（1-5500）（假设为3个节点），那么他就会在第一个节点进行存储，如果查找的话也会去第一个节点进行查询

## redis持久化策略

### RDB

​					RDB的存储方式：在指定的时间间隔内将内存中的数据集快照写入磁盘，也
						就是行话讲的Snapshot快照，它恢复时是将快照文件直接
						读到内存里



​		Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入
		到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换
		上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，
		这就确保了极高的性能如果需要进行大规模数据的恢复，且对于数据
		恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。
		RDB的缺点是最后一次持久化后的数据可能丢失



​		rdb的保存的文件： 在redis.conf中配置文件名称，默认为dump.rdb

​		![](C:/Users/topcom/Documents/Java%E4%BF%AE%E4%BB%99%E6%89%8B%E5%86%8C/Java_Manual/%E9%9D%A2%E8%AF%95/img/drb.png)



​		下面就是他的持久化的文件存储的路径



​		RDB持久化的保存策略

​		这是他的保存策略，如果60秒内发生了10000次数据操作则进行一次存储，

​		如果300秒发生了10次则会存入一次。如果900秒内发生了一次操作那么900秒后

​		就会备份一次，

​		![](C:/Users/topcom/Documents/Java%E4%BF%AE%E4%BB%99%E6%89%8B%E5%86%8C/Java_Manual/%E9%9D%A2%E8%AF%95/img/%E4%BF%9D%E5%AD%98%E7%AD%96%E7%95%A5rdb.png)

​		stop-writes-on-bgsave-error yes
		当Redis无法写入磁盘的话，直接关掉Redis的写操作

​		rdbcompression yes
		进行rdb保存时，将文件压缩

​		rdbchecksum yes
		在存储快照后，还可以让Redis使用CRC64算法来进行数
		据校验，但是这样做会增加大约10%的性能消耗，如果希
		望获取到最大的性能提升，可以关闭此功能

​	rdb的备份

​					先通过config get dir 查询rdb文件的目录
					将*.rdb的文件拷贝到别的地方

​			 	rdb的恢复

​			 		先把备份的文件拷贝到工作目录下
		 			关闭Redis
		 			启动Redis, 备份数据会直接加载

​				注：清先看清楚配置文件的RDB的文件名和路径

​	优点：

​					 节省磁盘空间
 					 恢复速度快

​	rdb的缺点

​					虽然Redis在fork时使用了写时拷贝技术,

​					但是如果数据庞大时还是比较消耗性能



​					在备份周期在一定间隔时间做一次备份，所以如果
					Redis意外down掉的话，就会丢失最后一次快照后的所有修改	

### AOF

​	 AOF默认不开启，需要手动在配置文件中配置

​			 可以在redis.conf中配置文件名称，默认为 appendonly.aof

​			![](C:/Users/topcom/Documents/Java%E4%BF%AE%E4%BB%99%E6%89%8B%E5%86%8C/Java_Manual/%E9%9D%A2%E8%AF%95/img/AOF.png)

​		这分别是是否开启。默认是关闭的而RDB默认是开启的，他的路径和RDB是一样的

​		下面这个就是文件名了

​		

​		那么如果RDB好AOF同时启动的话他会执行哪个呢？

​			AOF的备份机制和性能虽然和RDB不同, 但是备份和
			恢复的操作同RDB一样，都是拷贝备份文件，需要
			恢复时再拷贝到Redis工作目录下，启动系统即加载

​			**AOF和RDB同时开启，系统默认取AOF的数据**

​		持久化AOF

​			 AOF文件的保存路径，同RDB的路径一致

​			 如遇到AOF文件损坏，可通过
				redis-check-aof --fix appendonly.aof 进行恢复



​		AOF优点：

​				恢复数据全，不会丢失数据

​		缺点：

​				占用磁盘空间较大，并且恢复没有RDB快

- 如果只配置AOF，重启时加载AOF文件恢复数据；
- 如果同时配置了RBD和AOF，启动是只加载AOF文件恢复数据;
- 如果只配置RBD，启动时将加载dump文件恢复数据。

## 你们用了redis，redis的底层数据结构了解多少？

​		简单动态字符串

​		链表

​		字典

​		跳跃表

​		整数集合

​		压缩列表

## 知道动态字符串sds的优缺点么？ 注:sds为redis底层数据结构之一

​	核心：

​		更加高效的执行长度计算：

​				在C中获取长度是需要进行遍历的，但是在sds中直接获取size属性，时间复杂度为O(1)，C的原生字符串获取长度为O(n)



​		更加高效的执行追加操作：

​				他在拓展的时候会比实际的多，例如追加10但是他扩容了15个，这样的话他下面5次追加就不会进行扩容了，而且他使用了惰性空间释放，也就是例如多出了10个空间他会把这10个记录下来，留着下次追加使用，而不是直接将10个空间进行释放，但是这样会让我们的内存空间变大，这个也可以手动进行释放（在SDS）的Api中有记录



​		二进制安全：

​				因为C字符串以空字符作为字符串结束的标识，而对于一些二进制文件（如图片等），内容可能包括空字符串，因此C字符串无法正确存取；而所有 SDS 的API 都是以处理二进制的方式来处理 buf 里面的元素，并且 SDS 不是以空字符串来判断是否结束，而是以 len 属性表示的长度来判断字符串是否结束。 



sds 会为追加操作进行优化：加快追加操作的速度，并降低内存分配的次数，代价是多占用了一些内存，而且这些内存不会被主动释放。

## redis的单线程特性有什么优缺点？

优点：	

1. 代码更清晰，处理逻辑更简单
2. 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
3. 不存在多进程或者多线程导致的切换而消耗CPU

缺点：

1. 无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；

 

## 用过 Redis 的哪些数据结构, 分别用在什么场景?

### String

​			String类型他并不是只能存储String，也能用来存储Long，等等，他可以用来存储一些结构简单的数据，并且效率非常高，像日常的一些单个的值往里面存，例如用户的token，还有用户的信息

### Hash

​			Hash是一个字典类型，这个时候我们可以用它来存储一些需要频繁修改的对象，例如用户的积分（但一般也是在数据库中存储，Redis存储一般用来提高效率），那么我们需要对用户的积分进行改动，而且这种改动还比较频繁，那么我们可以使用Hash来进行存储这个用户对象，因为如果使用String的话他会全部的序列化出来再存储进去，这样造成的大量IO比较消耗性能

### List

​			List是一个列表，他其实是一个链表，但是更多的使用时是将他当做一个消息队列来使用，因为他可以push和pop这和Java中的Queue队列一样，我们可以使用它来做一个消息队列

### Set

​			Set是一个集合，他和Java中的Set也是一样的无序的不唯一的值，如果使用的话场景还是比较多的，例如向的好友列表，还有关注的用户，和粉丝，以及还能用来统计访问用户，比如统计某一天的用户访问量，和访问过的用户

### ZSet

​			ZSet是一个有序的集合，他可以用来存储集合并且做一个排序，那么我们可以使用他来进行一个点赞的操作，应为他去重并且有序，但实际上来说ZSet的应用场景其实并不多



​		这几个数据类型更多的是结合实际的业务需求来进行使用的



## 你们怎么解决缓存击穿问题的？

​		使用分布式锁，设置ex以及过期时间，然后进行数据库查询并重新添加到Redis中，没有获取到锁的对象Seelp睡眠一秒然后重新调用方法，这样就解决了缓存击穿的问题

## redis缓存给了多大的内存，命中率有多高抗住了多少QPS

## 超大Value打满网卡的问题如何规避这样的问题

## 你过往的工作经历中，是否出现过缓存集群事故，说说细并说说高可用的保障的方案

