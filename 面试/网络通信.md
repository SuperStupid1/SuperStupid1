# **计算机网络**

### TCP，UDP区别

1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接



2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付



3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流;UDP是面向报文的

UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）



4、每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信



5、TCP首部开销20字节;UDP的首部开销小，只有8个字节



6、TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道



总结：

​		TCP面向连接，即：需要连接才能发送数据，并且TCP提供的服务是可靠的有序的，不重复，不丢失，他将数据看成字节流进行传输，点对点的连接，TCP头部开销20字节，TCP是逻辑通信的可靠信道

​		

​		UDP是无连接的直接发送，UDP不保证可靠地将消息交付，UDP没有拥堵或阻塞状态，不会让发送效率变低，UDP可以一对一，一对多，多对多，多对一，首部8个字节，UDP是不可靠信道



​	优缺点对比：



​			TCP慢，但是消息传送可靠，并且无差错不丢失，但是效率并不高，并且首部开销大，还有可能阻塞或者拥堵



​			UDP是无连接的，不需要询问对方直接发送，发送速度快，并且没有阻塞拥堵状态，还能一对多多对多，首部开销少，但是不保证消息的可靠性，容易丢失，



​	在根据不同的场合使用不同的技术



### TCP核心

​			TCP的Flags有几个

​				URG：紧急指针标志

​				ACK：确认序号编制

​				PSH：push标志

​				RST：重置连接标志

​				SYN：同步序列好，用于建立连接过程

​				FIN：finish标志，用于释放链接

​			这些flags就是用于TCP的通信的核心



​			TCP的FLAG位由6个bit组成，分别代表ACK、 SYN、 FIN、 URG、 PSH、RST，都以置 l 表示有效。我们重点关注 SYN, ACK 和 FIN。 SYN ( Synchronize Sequence Numbers )用作建立连接时的同步信号 i ACK ( Acknowledgement )用于对 收到的数据进行确认，所确认的数据由确认序列号表示; FIN ( Finish )表示后面没有 数据需要发送，通常意昧着所建立的连接需要关闭了。

TCP 报头申的其他字段可以阅读盯C793 来掌握，本书在此不加赘述。接下来重点分析 TCP 中连接建立的原理。图 1-18 展示了正常情形下通过三次握手建立连接的过程。显然， B 机器是服务端角色， A 机器是客户端角色，前者需要在后者发起连接 建立请求时先打开某个端口等待数据传输，否则将无法正常建立连接。三次握手指的 是建立连接的三个步骤

•A 机器发出一个数据包并将 SYN 置 l ，表示希望建立连接。这个包中的序列 号假设是 x。

•B 机器收到 A 机器发过来的数据包后，通过 SYN 得知这是一个建立连接的 请求，于是发送一个响应包并将 SYN 和 ACK 标记都置 l。假设这个包中的 序列号是 y，而确认序列号必须是 x+l ，表示收到了 A 发过来的 SYNa 在TCP 中， SYN 被当作数据部分的一个字节。

•A 收到 B 的响应包后需进行确认，确认包中将 ACK 置 l，并将确认序列号 设置为 y+l ，表示收到了来自 B 的 SYNa

### 三次握手

​		TCP如何进行三次握手的呢？

​				假设我们通过A去访问B那么，A就会带着一个SYN进行连接请求B，这是第一次握手，如果B收到了并且统同意连接，那么B就会向A发送一个ACK+SYN用于确认并且请求连接，这里就是第二次的握手，然后A收到了B的ACK表示B已经同意了连接，那么A就会响应一个ACK表示收到了请求，这个时候就是真正的连接并且传输了，最后的连接就是第三次握手，这个就是TCP的三次握手

​		![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568026174284.png)

下面是完整的示例图：

```
** LISTEN ** 表示socket已经处于listen状态了，可以建立连接；

** SYN_SENT ** 表示socket在发出connect连接的时候，会首先发送SYN报文，然后等待另一端发送的确认报文(ACK)，表示这端已经发送完SYN报文了

** SYN_RCVD ** 表示一端已经接收到SYN报文了；

** ESTABLISHED ** 表示已经建立连接了，可以发送数据了

```

​	![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568026190137.png)



### 四次挥手

​		什么是TCP的四次挥手呢？

​		TCP的四次挥手就是A连接到了B，并且完成传输数据之后，这个连接关闭的过程我们称之为四次挥手，

​	TCP的四次挥手的过程	

​		那么我们又来假设A已经连接到了B，那么我们需要断开连接，首先我们的A会向B发起一个FIN来表示他传输完成，需要进行资源的释放，这里A向B发送了一个FIN表示第一次挥手，然后B收到了这个FIN，表示他知道了需要关闭资源，那么B就会给A发送一个ACK表示他收到了，然后进入到半关闭的CLOSE_WAIT状态，这个时候就是第二次挥手，然后B虽然处于了半关闭的状态，但是还是可以发送消息的，这个时候他会再次给A发送一个FIN表示，我已经关闭，你也关闭吧，这里就是第三次的挥手，那么A就会给B发送一个ACK表示他也收到了会进行关闭（但是不会立即关闭），这里的ACK表示A收到了然后给B发送确认，B收到之后才会进行关闭

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568026205427.png)

下面是完整示例

```
** FIN_WAIT_1 ** 表示在等待另一方的FIN报文，和FIN_WAIT_2的区别是，FIN_WAIT_1表示socket现在要主动关闭连接，在发送完FIN报文后socket进入FIN_WAIT_1状态，当收到另一方发送FIN的ACK之后立即进入FIN_WAIT_2状态；

** FIN_WAIT_2 ** 同上，此时需要做的事情是可能还会接收数据，然后等待另一方的FIN；

** TIME_WAIT ** 存在主动关闭的一方，表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL(Max Segment Lifetime))后即可回到CLOSED可用状态了，需要等一段时间时原因是网络是不可靠的，不能保证这个ACK发送成功了，如果失败了，对端会超时重传FIN；

** CLOSING ** 表示在发送FIN之后，没有收到对方的ACK，而是收到了对方的FIN，这中情况很少见，只有在两端几乎同时关闭同一个socket的时候才会出现CLOSING状态；

** CLOSE_WAIT ** 表示收到对方的FIN之后，回给对方ACK，此时处于CLOSE_WAIT状态，等待关闭，要看自己是否还有数据要发送；

** LAST_ACK ** 表示收到对方的FIN之后，回给对方ACK，然后自己也要关闭发送FIN，等待另一方的ACK时候的状态；

** CLOSED ** 这个状态表示连接已经断开。

```

![](https://blog-kang.oss-cn-beijing.aliyuncs.com/UTOOLS1568026218413.png)

### 为什么要三次握手

​		因为我们要知道TCP的通信是一定要保证数据的投递的可靠性，还有一致性，所以他建立连接的时候必须要确定双方的状态，要保证一定的可靠的投递，所以需要三次握手保证双方的数据传输环境，然后再进行通信

### 为什么要四次挥手

​		由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 

### 长连接和短连接

​		HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。



​		在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。  



​		而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

### 连接池适合长连接还是短连接

​		连接池适合长连接，因为在使用连接池的时候我们需要快速的连接，并且持续性的，所以我们使用长连接，在一般的连接池中也会设定最小连接数，和空闲连接数为的就是能快速的持续的传输数据所以连接池适合使用长连接

### Http和Https的区别

​		